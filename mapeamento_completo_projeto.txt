MAPEAMENTO COMPLETO DO PROJETO PYTHON
================================================================================

================================================================================
üìÑ ARQUIVO: .\app.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\debug_banco.py
================================================================================

from src.database.connection import get_conn

def normalizar(valor):
    if isinstance(valor, int):
        return valor
    if isinstance(valor, bytes):
        if len(valor) == 8:
            return int.from_bytes(valor, byteorder="little", signed=False)
        return int(valor.decode(errors="ignore"))
    return valor


def debug_concursos(limit=30):
    print("\nüîé ANALISANDO TABELA concursos\n")

    conn = get_conn()
    cursor = conn.cursor()

    cursor.execute("""
        SELECT id, concurso,
               d1,d2,d3,d4,d5,
               d6,d7,d8,d9,d10,
               d11,d12,d13,d14,d15
        FROM concursos
        ORDER BY id
        LIMIT ?
    """, (limit,))

    rows = cursor.fetchall()
    conn.close()

    if not rows:
        print("‚ùå Tabela concursos est√° vazia")
        return

    concursos = []

    for row in rows:
        id_db = row[0]
        concurso_raw = row[1]
        concurso = normalizar(concurso_raw)

        dezenas = [normalizar(d) for d in row[2:]]

        concursos.append(concurso)

        print(f"ID {id_db:4} | Concurso: {concurso_raw!r} -> {concurso}")
        print(f"     Dezenas: {dezenas}")

        # valida dezenas
        for d in dezenas:
            if not isinstance(d, int) or d < 1 or d > 25:
                print("     ‚ùå DEZENA INV√ÅLIDA DETECTADA")

    print("\nüìä VERIFICA√á√ÉO DE SEQU√äNCIA DOS CONCURSOS\n")

    for i in range(1, len(concursos)):
        diff = concursos[i] - concursos[i - 1]
        if diff != 1:
            print(
                f"‚ö†Ô∏è Salto anormal entre concursos: "
                f"{concursos[i-1]} ‚Üí {concursos[i]} (Œî = {diff})"
            )

    print("\n‚úÖ Diagn√≥stico conclu√≠do")


def debug_frequencias():
    print("\nüîé ANALISANDO TABELA frequencias\n")

    conn = get_conn()
    cursor = conn.cursor()

    cursor.execute("SELECT numero, quantidade, peso FROM frequencias ORDER BY numero")
    rows = cursor.fetchall()
    conn.close()

    if not rows:
        print("‚ùå Tabela frequencias est√° vazia")
        return

    for numero, qtd, peso in rows:
        numero_n = normalizar(numero)
        print(f"N√∫mero {numero_n} | qtd={qtd} | peso={peso}")

        if not isinstance(numero_n, int) or numero_n < 1 or numero_n > 25:
            print("‚ùå N√öMERO INV√ÅLIDO NA FREQU√äNCIA")


if __name__ == "__main__":
    debug_concursos()
    debug_frequencias()


================================================================================
üìÑ ARQUIVO: .\executarNeural.py
================================================================================

from src.engine.nn_cerebro import CerebroNeural
from src.engine.motor_multicerebro import gerar_jogo
from src.utils.extrator_features import extrair_features

nn = CerebroNeural()

jogo = gerar_jogo()
features = extrair_features(jogo)

score = nn.avaliar_jogo(features)
print("Score NN:", score)


================================================================================
üìÑ ARQUIVO: .\gerar_jogos_finais.py
================================================================================

from src.engine.seletor_jogos import SeletorJogos

seletor = SeletorJogos(usar_nn=True)
jogos_finais = seletor.gerar_jogos_filtrados()

for i, jogo in enumerate(jogos_finais, 1):
    print(f"Jogo {i}: {jogo}")


================================================================================
üìÑ ARQUIVO: .\mapear_projeto.py
================================================================================

import os

# ==========================
# CONFIGURA√á√ïES
# ==========================
PASTA_PROJETO = "."  # raiz do projeto
ARQUIVO_SAIDA = "mapeamento_completo_projeto.txt"

EXTENSOES_PERMITIDAS = (
    ".py",
    ".md",
    ".json",
    ".yml",
    ".yaml",
    ".ini",
)

PASTAS_IGNORADAS = {
    ".git",
    "__pycache__",
    ".txt",
    "venv",
    ".venv",
    "env",
    "node_modules",
    ".idea",
    ".vscode"
}

# ==========================
# FUN√á√ÉO PRINCIPAL
# ==========================
def mapear_projeto():
    with open(ARQUIVO_SAIDA, "w", encoding="utf-8") as saida:
        saida.write("MAPEAMENTO COMPLETO DO PROJETO PYTHON\n")
        saida.write("=" * 80 + "\n\n")

        for raiz, pastas, arquivos in os.walk(PASTA_PROJETO):
            # Remove pastas ignoradas
            pastas[:] = [p for p in pastas if p not in PASTAS_IGNORADAS]

            for arquivo in arquivos:
                if arquivo.lower().endswith(EXTENSOES_PERMITIDAS):
                    caminho_completo = os.path.join(raiz, arquivo)

                    saida.write("=" * 80 + "\n")
                    saida.write(f"üìÑ ARQUIVO: {caminho_completo}\n")
                    saida.write("=" * 80 + "\n\n")

                    try:
                        with open(caminho_completo, "r", encoding="utf-8") as f:
                            conteudo = f.read()
                            saida.write(conteudo)
                    except Exception as e:
                        saida.write(f"[ERRO AO LER O ARQUIVO: {e}]\n")

                    saida.write("\n\n")

    print(f"‚úÖ Mapeamento conclu√≠do! Arquivo gerado: {ARQUIVO_SAIDA}")

# ==========================
# EXECU√á√ÉO
# ==========================
if __name__ == "__main__":
    mapear_projeto()


================================================================================
üìÑ ARQUIVO: .\reimportar_concursos_corrigido.py
================================================================================

import csv
import os
from src.database.connection import get_conn

#CSV_PATH = "data\planilhas\Lotof√°cil.csv"  # ajuste se necess√°rio

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
CSV_PATH = os.path.join(BASE_DIR, "data", "planilhas", "Lotof√°cil.csv")


def recriar_tabela():
    conn = get_conn()
    cur = conn.cursor()

    cur.execute("DROP TABLE IF EXISTS concursos")

    cur.execute("""
        CREATE TABLE concursos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            concurso INTEGER NOT NULL,
            d1 INTEGER, d2 INTEGER, d3 INTEGER, d4 INTEGER, d5 INTEGER,
            d6 INTEGER, d7 INTEGER, d8 INTEGER, d9 INTEGER, d10 INTEGER,
            d11 INTEGER, d12 INTEGER, d13 INTEGER, d14 INTEGER, d15 INTEGER
        )
    """)

    conn.commit()
    conn.close()
    print("‚úÖ Tabela concursos recriada corretamente")


def importar_csv():
    conn = get_conn()
    cur = conn.cursor()

    with open(CSV_PATH, newline="", encoding="utf-8") as f:
        reader = csv.reader(f, delimiter=';')  # üëà CORRE√á√ÉO AQUI
        next(reader)  # pula cabe√ßalho

        total = 0
        for row in reader:
            if len(row) < 16:
                continue  # ignora linha quebrada

            concurso = int(row[0])
            dezenas = [int(x) for x in row[1:16]]

            cur.execute("""
                INSERT INTO concursos (
                    concurso,
                    d1,d2,d3,d4,d5,
                    d6,d7,d8,d9,d10,
                    d11,d12,d13,d14,d15
                ) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
            """, [concurso] + dezenas)

            total += 1

    conn.commit()
    conn.close()
    print(f"‚úÖ {total} concursos importados corretamente")


if __name__ == "__main__":
    recriar_tabela()
    importar_csv()

================================================================================
üìÑ ARQUIVO: .\test,bd.py
================================================================================

import sqlite3

conn = sqlite3.connect("data/lotofacil.db")
cursor = conn.cursor()
cursor.execute("PRAGMA table_info(concursos)")
print(cursor.fetchall())


================================================================================
üìÑ ARQUIVO: .\teste_motor.py
================================================================================

from src.engine.engine import executar_motor

executar_motor()


================================================================================
üìÑ ARQUIVO: .\teste_treinamento.py
================================================================================

from src.engine.trainer import treinar_sequencial

treinar_sequencial()


================================================================================
üìÑ ARQUIVO: .\teste_treinamento_github.py
================================================================================

from src.engine.trainer_GITHUB import treinar_sequencial

treinar_sequencial()


================================================================================
üìÑ ARQUIVO: .\treinamentoIncremental-TIME.py
================================================================================

import subprocess
import time

# Configura√ß√µes
tempo_limite_minutos = 120
segundos_totais = tempo_limite_minutos * 60
inicio_geral = time.time()

print(f"Iniciando loop de execu√ß√£o por {tempo_limite_minutos} minutos...")

while (time.time() - inicio_geral) < segundos_totais:
    print(f"\n--- Iniciando execu√ß√£o: {time.strftime('%H:%M:%S')} ---")
    
    # Executa o seu comando
    # O script espera o comando terminar para come√ßar a pr√≥xima repeti√ß√£o
    subprocess.run(["python", "-m", "teste_treinamento"])
    
    tempo_restante = segundos_totais - (time.time() - inicio_geral)
    
    if tempo_restante > 0:
        minutos_faltando = int(tempo_restante / 60)
        print(f"Execu√ß√£o finalizada. Tempo restante: {minutos_faltando} min.")
    else:
        print("Tempo esgotado!")

print(f"Per√≠odo de {tempo_limite_minutos} minutos conclu√≠do.")

================================================================================
üìÑ ARQUIVO: .\ver_memoria.py
================================================================================

import os
import sqlite3
from collections import Counter
from src.db.memoria_sqlite import carregar_memoria_premiada

# --- CONFIGURA√á√ÉO DE CAMINHOS ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, "data", "lotofacil.db")
DATA_DIR = os.path.join(BASE_DIR, "data")

caminho_diretorio_txt = os.path.join("src", "memory")
caminho_arquivo_txt = os.path.join(caminho_diretorio_txt, "memoriaSalva.txt")

os.makedirs(caminho_diretorio_txt, exist_ok=True)

def conectar():
    os.makedirs(DATA_DIR, exist_ok=True)
    return sqlite3.connect(DB_PATH)

def gerar_relatorio_texto():
    """Busca dados no banco e prepara o resumo estat√≠stico em string"""
    con = conectar()
    cur = con.cursor()
    
    try:
        cur.execute("""
            SELECT pontos, COUNT(*) 
            FROM memoria_premiada 
            GROUP BY pontos 
            ORDER BY pontos DESC
        """)
        resultados = cur.fetchall()
        total_jogos = sum(row[1] for row in resultados)
        
        linhas_relatorio = []
        linhas_relatorio.append("="*40)
        linhas_relatorio.append("üìä ESTAT√çSTICAS DA MEM√ìRIA")
        linhas_relatorio.append("="*40)
        
        if not resultados:
            linhas_relatorio.append("A mem√≥ria ainda est√° vazia.")
        else:
            for pontos, quantidade in resultados:
                percentual = (quantidade / total_jogos) * 100
                barra = "‚ñà" * int(percentual / 5)
                linhas_relatorio.append(f"{pontos} Pts: {quantidade:4d} | {barra} ({percentual:6.2f}%)")
        
        linhas_relatorio.append("-" * 40)
        linhas_relatorio.append(f"Total de jogos memorizados: {total_jogos}")
        linhas_relatorio.append("=" * 40 + "\n")
        
        return "\n".join(linhas_relatorio)
    except Exception as e:
        return f"Erro ao gerar estat√≠sticas: {e}"
    finally:
        con.close()

def executar_processamento():
    # 1. Carregar os jogos para a lista detalhada
    jogos = carregar_memoria_premiada()
    
    # 2. Gerar o resumo estat√≠stico
    resumo = gerar_relatorio_texto()
    
    print(resumo) # Mostra o resumo no console

    if not jogos:
        with open(caminho_arquivo_txt, "w", encoding="utf-8") as f:
            f.write(resumo)
            f.write("\nNenhum jogo detalhado encontrado.")
        print("Nenhum jogo encontrado para listar.")
        return

    # 3. Ordenar jogos (Maior pontua√ß√£o primeiro)
    jogos_ordenados = sorted(jogos, key=lambda x: x['pontos'], reverse=True)

    # 4. Gravar tudo no arquivo
    with open(caminho_arquivo_txt, "w", encoding="utf-8") as f:
        # Escreve o primeiro relat√≥rio (Estat√≠sticas)
        f.write(resumo)
        
        # Escreve o segundo relat√≥rio (Lista de Jogos)
        f.write("\nüèÜ LISTA DETALHADA DE JOGOS\n")
        f.write("-" * 40 + "\n")
        
        for j in jogos_ordenados:
            linha = f"{j['pontos']} pontos | {j['dezenas']}"
            f.write(linha + "\n")

    print(f"‚úÖ Relat√≥rio completo (Estat√≠sticas + Lista) salvo em:\nüëâ {caminho_arquivo_txt}")

if __name__ == "__main__":
    executar_processamento()

================================================================================
üìÑ ARQUIVO: .\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\.github\workflows\gerar_jogos_proximo_concurso.yml
================================================================================

name: üß† Gerar jogos para Lotof√°cil

on:
  # ‚ñ∂Ô∏è EXECU√á√ÉO MANUAL (BOT√ÉO)
  workflow_dispatch:

jobs:
  treinamento:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: üì• Checkout do reposit√≥rio
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üêç Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Instalar depend√™ncias
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      # üîé Garantir CSV
      - name: üîé Verificar CSV de concursos
        run: |
          if [ ! -f data/planilhas/Lotof√°cil.csv ]; then
            echo "‚ùå CSV n√£o encontrado: data/planilhas/Lotof√°cil.csv"
            exit 1
          fi
          echo "‚úÖ CSV encontrado"

      # üß† Executar treinamento
      - name: üß† Executar gerador
        run: |
          python -m src.scripts.gerar_jogos_proximo_concurso

      # üì§ Commit apenas dos relat√≥rios
      - name: üì§ Commit e Push do relat√≥rio
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git add src/reports/relatorios/*.txt || true
          git add src/memory/perfil_vencedor.json || true

          if ! git diff --cached --quiet; then
            git commit -m "üìä Relat√≥rio autom√°tico: $(date +'%Y-%m-%d %H:%M:%S')"
            git push
          else
            echo "Nenhuma mudan√ßa detectada."
          fi


================================================================================
üìÑ ARQUIVO: .\.github\workflows\monitorar_memoria.yml
================================================================================

name: üñ•Ô∏è Monitoramento de Mem√≥ria

on:
  # Permite rodar manualmente pela aba "Actions"
  workflow_dispatch:
  # Opcional: roda toda vez que voc√™ enviar c√≥digo
  # push:
  #   branches:
   #    - main
   #    - master

jobs:
  verificar_hardware:
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout do reposit√≥rio
        uses: actions/checkout@v4

      - name: üêç Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Instalar depend√™ncias de monitoramento
        run: |
          python -m pip install --upgrade pip
          # Caso seu script use a biblioteca psutil, instale-a aqui:
          pip install psutil || echo "psutil n√£o necess√°rio ou falhou"

      - name: üìä Executar verifica√ß√£o de mem√≥ria
        run: |
          python ver_memoria.py

          
      # üì§ Commit apenas dos relat√≥rios e mem√≥ria
      - name: üì§ Commit e Push do relat√≥rio
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git add src/reports/relatorios/*.txt || true
          git add src/memory/perfil_vencedor.json || true

          if ! git diff --cached --quiet; then
            git commit -m "üìä Relat√≥rio MEMORIA autom√°tico: $(date +'%Y-%m-%d %H:%M:%S')"
            git push
          else
            echo "Nenhuma mudan√ßa detectada."
          fi


================================================================================
üìÑ ARQUIVO: .\.github\workflows\TIME _TREINAMENTO.yml
================================================================================

name: üß† Treinamento IA Lotof√°cil TIME

on:
  # ‚ñ∂Ô∏è EXECU√á√ÉO MANUAL (BOT√ÉO)
  workflow_dispatch:

  # ‚è±Ô∏è EXECU√á√ÉO AUTOM√ÅTICA POR INTERVALO
  schedule:
    # Executa a cada 3 horas
    - cron: "0 */3 * * *"

jobs:
  treinamento:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: üì• Checkout do reposit√≥rio
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üêç Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Instalar depend√™ncias
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      # üîé Garantir CSV
      - name: üîé Verificar CSV de concursos
        run: |
          if [ ! -f data/planilhas/Lotof√°cil.csv ]; then
            echo "‚ùå CSV n√£o encontrado: data/planilhas/Lotof√°cil.csv"
            exit 1
          fi
          echo "‚úÖ CSV encontrado"

      # üß† Executar laborat√≥rio / treinamento
      - name: üß† Executar treinamento
        run: |
          python -m treinamentoIncremental-TIME

      # üì§ Commit apenas dos relat√≥rios e mem√≥ria
      - name: üì§ Commit e Push do relat√≥rio
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git add src/reports/relatorios/*.txt || true
          git add src/memory/perfil_vencedor.json || true

          if ! git diff --cached --quiet; then
            git commit -m "üìä Relat√≥rio autom√°tico: $(date +'%Y-%m-%d %H:%M:%S')"
            git push
          else
            echo "Nenhuma mudan√ßa detectada."
          fi


================================================================================
üìÑ ARQUIVO: .\.github\workflows\Treinamento da IA.yml
================================================================================

name: üß† Treinamento IA Lotof√°cil

on:
  # ‚ñ∂Ô∏è EXECU√á√ÉO MANUAL (BOT√ÉO)
  workflow_dispatch:

  # ‚è±Ô∏è EXECU√á√ÉO AUTOM√ÅTICA POR INTERVALO
  schedule:
    # Executa a cada 3 horas
    - cron: "0 */3 * * *"

  # üîÅ Opcional: ainda roda quando fizer push
  # push:
  #   branches:
  #    - main
  #     - master

jobs:
  treinamento:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: üì• Checkout do reposit√≥rio
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üêç Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Instalar depend√™ncias
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      # üîé Garantir CSV
      - name: üîé Verificar CSV de concursos
        run: |
          if [ ! -f data/planilhas/Lotof√°cil.csv ]; then
            echo "‚ùå CSV n√£o encontrado: data/planilhas/Lotof√°cil.csv"
            exit 1
          fi
          echo "‚úÖ CSV encontrado"

      # üß† Executar laborat√≥rio / treinamento
      #   python -m src.engine.calibrador_elite
      - name: üß† Executar treinamento
        run: |
          python -m teste_treinamento_github

      # üì§ Commit apenas dos relat√≥rios e mem√≥ria
      - name: üì§ Commit e Push do relat√≥rio
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git add src/reports/relatorios/*.txt || true
          git add src/memory/perfil_vencedor.json || true

          if ! git diff --cached --quiet; then
            git commit -m "üìä Relat√≥rio autom√°tico: $(date +'%Y-%m-%d %H:%M:%S')"
            git push
          else
            echo "Nenhuma mudan√ßa detectada."
          fi


================================================================================
üìÑ ARQUIVO: .\data\checkpoint.json
================================================================================

{
    "tentativas": 1,
    "melhor_pontuacao": 10,
    "jogos": [
        [
            1,
            2,
            4,
            7,
            8,
            9,
            10,
            13,
            14,
            15,
            17,
            18,
            19,
            20,
            21,
            22,
            24,
            25
        ]
    ]
}

================================================================================
üìÑ ARQUIVO: .\data\estado_motor.json
================================================================================

{
    "tentativas": 600,
    "melhor_pontos": 4,
    "limite_tentativas": 600
}

================================================================================
üìÑ ARQUIVO: .\src\config.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\logger.py
================================================================================

# ==========================================================
# LOGGER CENTRALIZADO ‚Äî IA LOTOF√ÅCIL
# Observabilidade sem interfer√™ncia
# ==========================================================

import os
from datetime import datetime

# ----------------------------------------------------------
# CONFIGURA√á√ïES GERAIS
# ----------------------------------------------------------
LOG_ATIVO = True
PASTA_LOGS = "logs"

os.makedirs(PASTA_LOGS, exist_ok=True)

# ----------------------------------------------------------
# FUN√á√ÉO BASE (NUNCA QUEBRA O SISTEMA)
# ----------------------------------------------------------
def _escrever_log(nome_arquivo, mensagem):
    if not LOG_ATIVO:
        return

    try:
        caminho = os.path.join(PASTA_LOGS, nome_arquivo)
        agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        with open(caminho, "a", encoding="utf-8") as f:
            f.write(f"[{agora}] {mensagem}\n")

    except Exception:
        # Seguran√ßa total: log nunca derruba o sistema
        pass

# ==========================================================
# LOGS ESPECIALIZADOS
# ==========================================================

def log_treinamento(msg):
    _escrever_log("treinamento.log", msg)

def log_motor(msg):
    _escrever_log("motor.log", msg)

def log_avaliador(msg):
    _escrever_log("avaliador.log", msg)

def log_pesos(msg):
    _escrever_log("pesos.log", msg)

def log_foco_1415(msg):
    _escrever_log("foco_1415.log", msg)

def log_geracao(msg):
    _escrever_log("geracao.log", msg)

# ==========================================================
# UTILIDADES (OPCIONAL)
# ==========================================================

def log_divisor(nome="GERAL"):
    linha = f"{'-'*10} {nome} {'-'*10}"
    _escrever_log("treinamento.log", linha)


================================================================================
üìÑ ARQUIVO: .\src\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\analysis\analyzer.py
================================================================================

from src.analysis.patterns import *
from src.analysis.score import calcular_score


def analisar_jogo(dezenas, dezenas_anteriores=None):
    """
    Analisa m√©tricas estruturais do jogo.
    N√ÉO calcula pontos reais.
    """

    metricas = {
        "impares": contar_impares(dezenas),
        "primos": contar_primos(dezenas),
        "multiplos_3": contar_multiplos_3(dezenas),
        "fibonacci": contar_fibonacci(dezenas),
        "moldura": contar_moldura(dezenas),
        "repetidas": contar_repetidas(dezenas, dezenas_anteriores),
    }

    metricas["score_heuristico"] = calcular_score(metricas)

    return metricas


def calcular_pontos_reais(jogo, resultado):
    return len(set(jogo) & set(resultado))


================================================================================
üìÑ ARQUIVO: .\src\analysis\patterns.py
================================================================================

PRIMOS = {2, 3, 5, 7, 11, 13, 17, 19, 23}
FIBONACCI = {1, 2, 3, 5, 8, 13, 21}
MOLDURA = {1,2,3,4,5,6,10,11,15,16,20,21,22,23,24,25}

def contar_impares(dezenas):
    return sum(1 for d in dezenas if d % 2 != 0)

def contar_primos(dezenas):
    return sum(1 for d in dezenas if d in PRIMOS)

def contar_multiplos_3(dezenas):
    return sum(1 for d in dezenas if d % 3 == 0)

def contar_fibonacci(dezenas):
    return sum(1 for d in dezenas if d in FIBONACCI)

def contar_moldura(dezenas):
    return sum(1 for d in dezenas if d in MOLDURA)

def contar_repetidas(dezenas, anterior):
    if not anterior:
        return 0
    return len(set(dezenas) & set(anterior))


================================================================================
üìÑ ARQUIVO: .\src\analysis\pontos.py
================================================================================

def calcular_pontos_reais(jogo, resultado):
    """
    Calcula acertos reais entre jogo gerado e resultado oficial.
    """
    return len(set(jogo) & set(resultado))


================================================================================
üìÑ ARQUIVO: .\src\analysis\score.py
================================================================================

def score_faixa(valor, faixas):
    return 1 if valor in faixas else 0


def calcular_score(metricas):
    score = 0

    score += score_faixa(metricas["impares"], {8, 9})
    score += score_faixa(metricas["primos"], {5, 6})
    score += score_faixa(metricas["multiplos_3"], {4, 6})
    score += score_faixa(metricas["fibonacci"], {3, 5})
    score += score_faixa(metricas["moldura"], {9, 10})
    score += score_faixa(metricas["repetidas"], {8, 10})

    return score


================================================================================
üìÑ ARQUIVO: .\src\analysis\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\core\aprendizado.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\core\checkpoint.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\core\gerador.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\core\regras.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\core\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\database\connection.py
================================================================================

import sqlite3
import os

DB_PATH = "data/lotofacil.db"

def get_conn():
    if not os.path.exists("data"):
        os.makedirs("data")

    conn = sqlite3.connect(DB_PATH)
    return conn


================================================================================
üìÑ ARQUIVO: .\src\database\db_init.py
================================================================================

import sqlite3
from pathlib import Path

DB_PATH = Path("data/lotofacil.db")
SCHEMA_PATH = Path("src/database/db_schema.sql")

def criar_banco():
    DB_PATH.parent.mkdir(exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    with open(SCHEMA_PATH, "r", encoding="utf-8") as f:
        cursor.executescript(f.read())

    conn.commit()
    conn.close()

    print("‚úÖ Banco SQLite estruturado com schema profissional.")

if __name__ == "__main__":
    criar_banco()


================================================================================
üìÑ ARQUIVO: .\src\database\db_manager.py
================================================================================

import sqlite3
from pathlib import Path
from datetime import datetime

DB_PATH = Path("data/lotofacil.db")

def conectar():
    return sqlite3.connect(DB_PATH)

def salvar_concurso(concurso, dezenas, data=None):
    conn = conectar()
    cursor = conn.cursor()

    cursor.execute("""
    INSERT OR IGNORE INTO concursos (concurso, dezenas, data)
    VALUES (?, ?, ?)
    """, (concurso, ",".join(map(str, dezenas)), data))

    conn.commit()
    conn.close()

def salvar_tentativa(concurso, tentativa, dezenas, acertos, score, tempo_exec):
    conn = conectar()
    cursor = conn.cursor()

    cursor.execute("""
    INSERT INTO tentativas
    (concurso, tentativa, dezenas, acertos, score, tempo_exec, timestamp)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """, (
        concurso,
        tentativa,
        ",".join(map(str, dezenas)),
        acertos,
        score,
        tempo_exec,
        datetime.now().isoformat()
    ))

    conn.commit()
    conn.close()

def salvar_checkpoint(concurso_atual, tentativa_atual):
    conn = conectar()
    cursor = conn.cursor()

    cursor.execute("""
    INSERT OR REPLACE INTO checkpoint
    (id, concurso_atual, tentativa_atual, inicio_timestamp)
    VALUES (1, ?, ?, ?)
    """, (
        concurso_atual,
        tentativa_atual,
        datetime.now().isoformat()
    ))

    conn.commit()
    conn.close()

def carregar_checkpoint():
    conn = conectar()
    cursor = conn.cursor()

    cursor.execute("SELECT concurso_atual, tentativa_atual FROM checkpoint WHERE id=1")
    row = cursor.fetchone()
    conn.close()

    if row:
        return row[0], row[1]
    return None, None


================================================================================
üìÑ ARQUIVO: .\src\database\import_csv.py
================================================================================

import pandas as pd
from src.database.connection import get_conn

def importar_csv(caminho_csv):
    df = pd.read_csv(caminho_csv, sep=';')

    conn = get_conn()
    cursor = conn.cursor()

    # Limpa dados antigos
    cursor.execute("DELETE FROM concursos")
    cursor.execute("DELETE FROM frequencias")

    # Insere concursos
    for _, row in df.iterrows():
        dezenas = row.iloc[1:16].tolist()
        cursor.execute("""
        INSERT INTO concursos (
            concurso,d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15
        ) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
        """, [row.iloc[0]] + dezenas)

    # Calcula frequ√™ncias
    contagem = {i: 0 for i in range(1, 26)}
    for _, row in df.iterrows():
        for dez in row.iloc[1:16]:
            contagem[int(dez)] += 1

    total = sum(contagem.values())

    for numero, qtd in contagem.items():
        peso = qtd / total
        cursor.execute("""
        INSERT INTO frequencias (numero, quantidade, peso)
        VALUES (?,?,?)
        """, (numero, qtd, peso))

    conn.commit()
    conn.close()
    print("‚úÖ CSV importado e frequ√™ncias calculadas")

if __name__ == "__main__":
    importar_csv("data\planilhas\Lotof√°cil.csv")



================================================================================
üìÑ ARQUIVO: .\src\database\init_db.py
================================================================================

from src.database.connection import get_conn

def init_db():
    conn = get_conn()
    cursor = conn.cursor()

    # Tabela de concursos
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS concursos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        concurso INTEGER,
        d1 INTEGER, d2 INTEGER, d3 INTEGER, d4 INTEGER, d5 INTEGER,
        d6 INTEGER, d7 INTEGER, d8 INTEGER, d9 INTEGER, d10 INTEGER,
        d11 INTEGER, d12 INTEGER, d13 INTEGER, d14 INTEGER, d15 INTEGER
    )
    """)

    # Tabela de frequ√™ncias
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS frequencias (
        numero INTEGER PRIMARY KEY,
        quantidade INTEGER,
        peso REAL
    )
    """)

    # Estado do motor
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS estado_motor (
        id INTEGER PRIMARY KEY,
        tentativas INTEGER,
        melhor_pontos INTEGER
    )
    """)

    # Inicializa estado se n√£o existir
    cursor.execute("SELECT COUNT(*) FROM estado_motor")
    if cursor.fetchone()[0] == 0:
        cursor.execute("""
        INSERT INTO estado_motor (id, tentativas, melhor_pontos)
        VALUES (1, 0, 0)
        """)

    conn.commit()
    conn.close()
    print("‚úÖ Banco inicializado com sucesso")

if __name__ == "__main__":
    init_db()


================================================================================
üìÑ ARQUIVO: .\src\database\learning.py
================================================================================

import sqlite3
from src.database.connection import get_conn

def init_learning():
    conn = get_conn()
    cursor = conn.cursor()

    cursor.execute("""
    CREATE TABLE IF NOT EXISTS aprendizado (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        concurso INTEGER,
        pontos INTEGER,
        base TEXT
    )
    """)

    conn.commit()
    conn.close()


def salvar_aprendizado(concurso, pontos, base):
    conn = get_conn()
    cursor = conn.cursor()

    cursor.execute("""
    INSERT INTO aprendizado (concurso, pontos, base)
    VALUES (?, ?, ?)
    """, (concurso, pontos, str(sorted(base))))

    conn.commit()
    conn.close()


================================================================================
üìÑ ARQUIVO: .\src\database\state.py
================================================================================

import json
import os

CAMINHO_ESTADO = "data/estado_motor.json"

ESTADO_PADRAO = {
    "tentativas": 0,
    "melhor_pontos": 0,
    "limite_tentativas": 600
}

def carregar_estado():
    if not os.path.exists("data"):
        os.makedirs("data")

    if not os.path.exists(CAMINHO_ESTADO):
        salvar_estado(
            ESTADO_PADRAO["tentativas"],
            ESTADO_PADRAO["melhor_pontos"],
            ESTADO_PADRAO["limite_tentativas"]
        )
        return ESTADO_PADRAO.copy()

    with open(CAMINHO_ESTADO, "r", encoding="utf-8") as f:
        return json.load(f)

def salvar_estado(tentativas, melhor_pontos, limite_tentativas=None):
    estado = {
        "tentativas": tentativas,
        "melhor_pontos": melhor_pontos,
        "limite_tentativas": limite_tentativas or ESTADO_PADRAO["limite_tentativas"]
    }

    with open(CAMINHO_ESTADO, "w", encoding="utf-8") as f:
        json.dump(estado, f, indent=4)


================================================================================
üìÑ ARQUIVO: .\src\database\training_log.py
================================================================================

from src.database.connection import get_conn

def init_training_log():
    conn = get_conn()
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS training_log (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            concurso INTEGER,
            pontos INTEGER,
            score REAL,
            base TEXT
        )
    """)

    conn.commit()
    conn.close()


def salvar_log(concurso, pontos, score, base):
    conn = get_conn()
    cursor = conn.cursor()

    cursor.execute("""
        INSERT INTO training_log (concurso, pontos, score, base)
        VALUES (?, ?, ?, ?)
    """, (concurso, pontos, score, str(base)))

    conn.commit()
    conn.close()


================================================================================
üìÑ ARQUIVO: .\src\database\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\db\banco.py
================================================================================

import sqlite3

DB_PATH = "data/lotofacil.db"


def carregar_concursos():
    con = sqlite3.connect(DB_PATH)
    cur = con.cursor()

    cur.execute("SELECT * FROM concursos ORDER BY concurso")

    concursos = []
    for row in cur.fetchall():
        concurso = row[0]
        dezenas = list(map(int, row[1:16]))
        concursos.append((concurso, dezenas))

    con.close()
    return concursos


================================================================================
üìÑ ARQUIVO: .\src\db\memoria_sqlite.py
================================================================================

import sqlite3
import os
import json
from collections import Counter

# ==========================================================
# üìÅ CONFIGURA√á√ÉO DE DIRET√ìRIO E BANCO
# ==========================================================

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.abspath(os.path.join(BASE_DIR, "..", ".."))

DATA_DIR = os.path.join(PROJECT_ROOT, "data")
DB_PATH = os.path.join(DATA_DIR, "lotofacil.db")


def conectar():
    os.makedirs(DATA_DIR, exist_ok=True)
    return sqlite3.connect(DB_PATH)


# ==========================================================
# üóÑÔ∏è GARANTIA DE TABELAS
# ==========================================================

def garantir_tabelas():
    con = conectar()
    cur = con.cursor()

    # Mem√≥ria de jogos premiados da IA
    cur.execute("""
        CREATE TABLE IF NOT EXISTS memoria_premiada (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            concurso INTEGER,
            dezenas TEXT NOT NULL,
            pontos INTEGER NOT NULL
        )
    """)

    # Hist√≥rico de resultados reais (opcional / futuro)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS resultados (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            concurso INTEGER,
            dezenas TEXT NOT NULL
        )
    """)

    con.commit()
    con.close()


# ==========================================================
# üíæ SALVAR JOGO PREMIADO
# ==========================================================

def salvar_jogo_premiado(concurso, dezenas, pontos):
    if pontos < 11:
        return False

    garantir_tabelas()

    con = conectar()
    cur = con.cursor()

    dezenas_txt = ",".join(map(str, dezenas))

    cur.execute("""
        INSERT INTO memoria_premiada (concurso, dezenas, pontos)
        VALUES (?, ?, ?)
    """, (concurso, dezenas_txt, pontos))

    con.commit()
    con.close()

    return True


# ==========================================================
# üì• LEITURAS DA MEM√ìRIA PREMIADA
# ==========================================================

def carregar_memoria_premiada():
    garantir_tabelas()

    con = conectar()
    cur = con.cursor()

    cur.execute("""
        SELECT dezenas, pontos
        FROM memoria_premiada
        WHERE pontos >= 11
    """)

    jogos = []
    for dezenas, pontos in cur.fetchall():
        jogos.append({
            "dezenas": list(map(int, dezenas.split(","))),
            "pontos": pontos
        })

    con.close()
    return jogos


def carregar_frequencia_dezenas():
    garantir_tabelas()

    con = conectar()
    cur = con.cursor()

    cur.execute("""
        SELECT dezenas
        FROM memoria_premiada
        WHERE pontos >= 11
    """)

    contador = Counter()

    for (dezenas,) in cur.fetchall():
        nums = map(int, dezenas.split(","))
        contador.update(nums)

    con.close()
    return dict(contador)


def carregar_jogos_memoria():
    """
    Retorna lista de tuplas:
    ([dezenas], pontos)
    """
    garantir_tabelas()

    conn = conectar()
    cur = conn.cursor()

    cur.execute("""
        SELECT dezenas, pontos
        FROM memoria_premiada
    """)

    dados = []
    for dezenas_str, pontos in cur.fetchall():
        dezenas = [int(d) for d in dezenas_str.split(",")]
        dados.append((dezenas, pontos))

    conn.close()
    return dados


def carregar_jogos_premiados(min_pontos=14):
    """
    Usado pelo calibrador elite
    """
    garantir_tabelas()

    conn = conectar()
    cursor = conn.cursor()

    cursor.execute("""
        SELECT dezenas, pontos
        FROM memoria_premiada
        WHERE pontos >= ?
    """, (min_pontos,))

    registros = cursor.fetchall()
    conn.close()

    jogos = []
    for dezenas_str, pontos in registros:
        dezenas = [int(x) for x in dezenas_str.split(",")]
        jogos.append({
            "dezenas": dezenas,
            "pontos": pontos
        })

    return jogos


# ==========================================================
# üìä HIST√ìRICO PARA ESTAT√çSTICAS
# ==========================================================

def carregar_historico():
    """
    Retorna lista de listas com dezenas
    Usado para dezenas quentes e frias
    Prioridade:
    1Ô∏è‚É£ resultados reais (se existirem)
    2Ô∏è‚É£ mem√≥ria premiada da IA
    """

    garantir_tabelas()

    conn = conectar()
    cursor = conn.cursor()

    # Tenta usar resultados reais primeiro
    cursor.execute("SELECT dezenas FROM resultados")
    rows = cursor.fetchall()

    historico = []

    if rows:
        for (dezenas_str,) in rows:
            dezenas = [int(x) for x in dezenas_str.split(",")]
            historico.append(dezenas)
    else:
        # Fallback: usa mem√≥ria premiada
        cursor.execute("SELECT dezenas FROM memoria_premiada")
        rows = cursor.fetchall()
        for (dezenas_str,) in rows:
            dezenas = [int(x) for x in dezenas_str.split(",")]
            historico.append(dezenas)

    conn.close()
    return historico


================================================================================
üìÑ ARQUIVO: .\src\db\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\engine\aprendiz.py
================================================================================

import json
import os
from collections import Counter
from src.db.memoria_sqlite import carregar_memoria_premiada

ARQUIVO_PERFIL = "src/memory/perfil_vencedor.json"


def gerar_perfil_vencedor():
    jogos = carregar_memoria_premiada()

    if not jogos:
        print("‚ö†Ô∏è Nenhum jogo premiado (11+) para aprendizado")
        return

    contador = Counter()
    pares = []
    somas = []

    for jogo in jogos:
        dezenas = jogo["dezenas"]
        contador.update(dezenas)
        pares.append(sum(1 for d in dezenas if d % 2 == 0))
        somas.append(sum(dezenas))

    # üî• TOP dezenas mais recorrentes
    top_dezenas = [int(d) for d, _ in contador.most_common(15)]

    perfil = {
        "top_dezenas": top_dezenas,
        "frequencia_dezenas": dict(contador),
        "media_pares": round(sum(pares) / len(pares), 2),
        "media_soma": round(sum(somas) / len(somas), 2),
        "total_jogos": len(jogos)
    }

    os.makedirs("src/memory", exist_ok=True)

    with open(ARQUIVO_PERFIL, "w", encoding="utf-8") as f:
        json.dump(perfil, f, indent=4, ensure_ascii=False)

    print(f"üß† Perfil vencedor aprendido com {len(jogos)} jogos")


def obter_perfil_vencedor():
    """
    Retorna APENAS uma lista de dezenas (contrato fixo)
    """
    if not os.path.exists(ARQUIVO_PERFIL):
        return []

    with open(ARQUIVO_PERFIL, "r", encoding="utf-8") as f:
        perfil = json.load(f)

    return perfil.get("top_dezenas", [])


================================================================================
üìÑ ARQUIVO: .\src\engine\avaliador.py
================================================================================

from collections import defaultdict


class Avaliador:
    def __init__(self):
        self.total = 0
        self.soma_pontos = 0
        self.soma_pesos = 0.0

        self.distribuicao = defaultdict(int)
        self.distribuicao_peso = defaultdict(float)

        self.premiados = 0

    def peso_aprendizado(self, pontos):
        if pontos >= 15:
            return 3.0
        elif pontos >= 14:
            return 2.0
        elif pontos >= 12:
            return 1.0
        elif pontos >= 11:
            return 0.4
        else:
            return 0.2

    def registrar(self, pontos):
        peso = self.peso_aprendizado(pontos)

        self.total += 1
        self.soma_pontos += pontos
        self.soma_pesos += peso

        self.distribuicao[pontos] += 1
        self.distribuicao_peso[pontos] += peso

        if pontos >= 11:
            self.premiados += 1

    # -------------------------------
    # M√âTRICAS
    # -------------------------------
    def media(self):
        return self.soma_pontos / self.total if self.total else 0

    def media_ponderada(self):
        return self.soma_pontos / self.soma_pesos if self.soma_pesos else 0

    def taxa(self):
        return (self.premiados / self.total) * 100 if self.total else 0

    def relatorio(self):
        print("\nüìä RELAT√ìRIO DE DESEMPENHO")
        print("-" * 40)
        print(f"Jogos avaliados        : {self.total}")
        print(f"M√©dia simples          : {self.media():.2f}")
        print(f"M√©dia ponderada        : {self.media_ponderada():.2f}")
        print(f"Jogos 11+              : {self.premiados}")
        print(f"Taxa premiada          : {self.taxa():.2f}%")

        print("\nDistribui√ß√£o de pontos (peso):")
        for pontos in sorted(self.distribuicao):
            print(
                f"  {pontos} pontos ‚Üí {self.distribuicao[pontos]} jogos "
                f"(peso acumulado: {self.distribuicao_peso[pontos]:.2f})"
            )

    def resumo(self):
        return {
            "Jogos avaliados": self.total,
            "M√©dia simples": round(self.media(), 2),
            "M√©dia ponderada": round(self.media_ponderada(), 2),
            "Jogos 11+": self.premiados,
            "Taxa premiada (%)": round(self.taxa(), 2)
        }

    def relatorio_texto(self):
        linhas = []
        linhas.append("üìä RELAT√ìRIO DE DESEMPENHO")
        linhas.append("-" * 40)
        linhas.append(f"Jogos avaliados        : {self.total}")
        linhas.append(f"M√©dia simples          : {self.media():.2f}")
        linhas.append(f"M√©dia ponderada        : {self.media_ponderada():.2f}")
        linhas.append(f"Jogos 11+              : {self.premiados}")
        linhas.append(f"Taxa premiada          : {self.taxa():.2f}%\n")

        linhas.append("Distribui√ß√£o de pontos (peso):")
        for pontos in sorted(self.distribuicao):
            linhas.append(
                f"  {pontos} pontos ‚Üí {self.distribuicao[pontos]} jogos "
                f"(peso: {self.distribuicao_peso[pontos]:.2f})"
            )

        return "\n".join(linhas) + "\n\n"


================================================================================
üìÑ ARQUIVO: .\src\engine\calibrador_elite.py
================================================================================

import json
import os
from statistics import mean
from collections import Counter

from src.db.memoria_sqlite import carregar_jogos_premiados
from src.utils.dados import carregar_resultados


ARQ_CALIBRACAO = "src/engine/calibracao_elite.json"


def analisar_jogo(jogo, ultimo_resultado, quentes, frias):
    return {
        "quentes": len(set(jogo) & quentes),
        "frias": len(set(jogo) & frias),
        "repetidas": len(set(jogo) & set(ultimo_resultado)),
        "pares": sum(1 for n in jogo if n % 2 == 0),
        "soma": sum(jogo)
    }


def calibrar_filtro_elite():
    print("üß™ Calibra√ß√£o Elite iniciada")

    jogos = carregar_jogos_premiados(min_pontos=14)
    resultados = carregar_resultados()

    if not jogos:
        print("‚ö†Ô∏è Nenhum jogo premiado encontrado para calibra√ß√£o")
        return

    ultimo_resultado = resultados[-1]["dezenas"]

    # üî• Frequ√™ncia global
    freq = Counter()
    for r in resultados:
        freq.update(r["dezenas"])

    ordenadas = [n for n, _ in freq.most_common()]
    quentes = set(ordenadas[:10])
    frias = set(ordenadas[-10:])

    metricas = {
        "quentes": [],
        "frias": [],
        "repetidas": [],
        "pares": [],
        "soma": []
    }

    for jogo in jogos:
        dados = analisar_jogo(jogo["dezenas"], ultimo_resultado, quentes, frias)
        for k in metricas:
            metricas[k].append(dados[k])

    calibracao = {}
    for k, valores in metricas.items():
        calibracao[k] = {
            "min": min(valores),
            "max": max(valores),
            "media": round(mean(valores), 2)
        }

    os.makedirs(os.path.dirname(ARQ_CALIBRACAO), exist_ok=True)
    with open(ARQ_CALIBRACAO, "w", encoding="utf-8") as f:
        json.dump(calibracao, f, indent=4)

    print("‚úÖ Calibra√ß√£o conclu√≠da")
    print(f"üìÅ Arquivo salvo em {ARQ_CALIBRACAO}")


================================================================================
üìÑ ARQUIVO: .\src\engine\calibrador_pesos.py
================================================================================

from statistics import mean

def calibrar_pesos(jogos_premiados):
    """
    Recebe lista de:
    {
        'dezenas': [...],
        'pontos': 14 ou 15
    }
    Retorna pesos calibrados
    """

    metricas = {
        "quentes": [],
        "frias": [],
        "repetidas": [],
        "pares": [],
    }

    for jogo in jogos_premiados:
        dezenas = set(jogo["dezenas"])

        metricas["quentes"].append(jogo.get("q_quentes", 0))
        metricas["frias"].append(jogo.get("q_frias", 0))
        metricas["repetidas"].append(jogo.get("q_repetidas", 0))
        metricas["pares"].append(jogo.get("q_pares", 0))

    pesos = {
        "peso_quentes": round(20 / (mean(metricas["quentes"]) + 1), 2),
        "peso_frias": round(5 / (mean(metricas["frias"]) + 1), 2),
        "peso_repetidas": round(30 / (mean(metricas["repetidas"]) + 1), 2),
        "peso_pares": round(10 / (mean(metricas["pares"]) + 1), 2),
    }

    return pesos


================================================================================
üìÑ ARQUIVO: .\src\engine\cerebros_memoria.py
================================================================================

"""
üß† C√âREBROS DE MEM√ìRIA ‚Äî IA HIST√ìRICA
Avalia jogos com base em tudo que j√° deu 11‚Äì15 pontos.
"""

from collections import Counter
from typing import List, Tuple

from src.db.memoria_sqlite import carregar_memoria_premiada
from src.utils.logger import logger


class CerebrosMemoria:
    """
    Motor de avalia√ß√£o baseado em mem√≥ria premiada real.
    """

    def __init__(self):
        self.memoria = []
        self.contagem_dezenas = Counter()
        self._carregar_memoria()

    # --------------------------------------------------
    # üì• CARGA DA MEM√ìRIA
    # --------------------------------------------------
    def _carregar_memoria(self):
        registros = carregar_memoria_premiada()

        if not registros:
            logger.warning("‚ö†Ô∏è Mem√≥ria premiada vazia")
            return

        for r in registros:
            dezenas = sorted(r["dezenas"])
            pontos = int(r["pontos"])

            self.memoria.append({
                "dezenas": dezenas,
                "pontos": pontos
            })

            # Peso maior para jogos melhores
            peso = pontos - 10  # 11‚Üí1, 15‚Üí5
            for d in dezenas:
                self.contagem_dezenas[d] += peso

        logger.info(
            f"üß† Mem√≥ria carregada | Jogos: {len(self.memoria)} | "
            f"Dezenas √∫nicas: {len(self.contagem_dezenas)}"
        )

    # --------------------------------------------------
    # üéØ SCORE PRINCIPAL
    # --------------------------------------------------
    def score_final(self, jogo: List[int]) -> Tuple[float, dict]:
        """
        Score baseado em alinhamento com a mem√≥ria hist√≥rica
        """

        score = 0.0
        detalhes = {}

        # üî¢ Score por dezenas fortes na mem√≥ria
        pontos_memoria = sum(
            self.contagem_dezenas.get(d, 0)
            for d in jogo
        )

        score += pontos_memoria
        detalhes["memoria_dezenas"] = pontos_memoria

        # üîÅ Similaridade com jogos premiados
        similaridades = []
        for m in self.memoria:
            inter = len(set(jogo) & set(m["dezenas"]))
            if inter >= 11:
                similaridades.append(inter)

        bonus_similaridade = sum(similaridades) * 2
        score += bonus_similaridade
        detalhes["similaridade"] = bonus_similaridade

        return score, detalhes


# --------------------------------------------------
# üß† SINGLETON GLOBAL
# --------------------------------------------------
_cerebro_global = None


def obter_cerebros_memoria() -> CerebrosMemoria:
    global _cerebro_global

    if _cerebro_global is None:
        _cerebro_global = CerebrosMemoria()

    return _cerebro_global


================================================================================
üìÑ ARQUIVO: .\src\engine\cerebro_neural.py
================================================================================

# ==========================================================
# ü§ñ C√âREBRO NEURAL CONSULTIVO (SIMPLIFICADO)
# ==========================================================

def avaliar_base(base):
    pares = len([x for x in base if x % 2 == 0])
    impares = len(base) - pares

    equilibrio = 1 - abs(pares - impares) / len(base)

    score = round(0.6 * equilibrio + 0.4, 2)

    return {
        "score": score,
        "equilibrio": equilibrio,
        "aprovado": score >= 0.75
    }


================================================================================
üìÑ ARQUIVO: .\src\engine\checkpoint.py
================================================================================

# src/engine/checkpoint.py

import json
import os

CHECKPOINT_PATH = "data/checkpoint.json"


def salvar_checkpoint(dados):
    os.makedirs("data", exist_ok=True)
    with open(CHECKPOINT_PATH, "w", encoding="utf-8") as f:
        json.dump(dados, f, indent=4)


def carregar_checkpoint():
    if not os.path.exists(CHECKPOINT_PATH):
        return None
    with open(CHECKPOINT_PATH, "r", encoding="utf-8") as f:
        return json.load(f)


================================================================================
üìÑ ARQUIVO: .\src\engine\engine.py
================================================================================

from src.engine.brains.brain_stats import gerar_base_stats
from src.engine.brains.brain_explorer import gerar_base_exploracao
from src.engine.scorer import score_total
from src.database.state import carregar_estado, salvar_estado
from src.analysis.analyzer import analisar_jogo
from src.analysis.pontos import calcular_pontos_reais
from src.database.connection import get_conn

TODAS = list(range(1, 26))


def executar_motor(resultado_real):
    print("üöÄ Motor Multic√©rebro iniciado")

    estado = carregar_estado()
    tentativa = estado["tentativas"]
    limite = estado["limite_tentativas"]

    conn = get_conn()
    cursor = conn.cursor()

    cursor.execute("SELECT numero FROM frequencias ORDER BY peso DESC")
    freq_rank = [int(r[0]) for r in cursor.fetchall()]

    melhor_pontos = 0
    melhor_score = 0
    melhor_base = None

    while tentativa < limite:
        tentativa += 1

        base_stats = gerar_base_stats(freq_rank)
        base_exploracao = gerar_base_exploracao(TODAS)

        metricas = analisar_jogo(base_stats)
        pontos_reais = calcular_pontos_reais(base_stats, resultado_real)

        score = score_total(
            base_stats,
            [base_exploracao],
            pontos_reais,
            metricas["score_heuristico"]
        )

        if pontos_reais > melhor_pontos or score > melhor_score:
            melhor_pontos = pontos_reais
            melhor_score = score
            melhor_base = base_stats

            print(f"‚≠ê Novo melhor: {melhor_pontos} pontos | score {melhor_score}")

        salvar_estado(tentativa, melhor_pontos)

        if pontos_reais >= 11:
            break

    conn.close()

    return {
        "pontos": melhor_pontos,
        "score": melhor_score,
        "base": melhor_base
    }


================================================================================
üìÑ ARQUIVO: .\src\engine\estatisticas.py
================================================================================

# ==========================================================
# üìä ESTAT√çSTICAS ‚Äî DEZENAS QUENTES E FRIAS
# ==========================================================

from collections import Counter
from src.db.memoria_sqlite import carregar_historico


def calcular_dezenas_quentes_frias():
    """
    Retorna duas listas:
    - dezenas quentes (mais frequentes)
    - dezenas frias (menos frequentes)
    """

    historico = carregar_historico()

    todas = []
    for concurso in historico:
        todas.extend(concurso)

    freq = Counter(todas)

    ordenadas = freq.most_common()

    dezenas_quentes = [n for n, _ in ordenadas[:8]]
    dezenas_frias = [n for n, _ in ordenadas[-8:]]

    return dezenas_quentes, dezenas_frias


================================================================================
üìÑ ARQUIVO: .\src\engine\evaluator.py
================================================================================

def contar_acertos(base, concurso_real):
    """
    base: set ou list com 18 dezenas
    concurso_real: set com 15 dezenas
    """
    return len(set(base) & set(concurso_real))


================================================================================
üìÑ ARQUIVO: .\src\engine\extrator_nucleo.py
================================================================================

# ==========================================================
# üß† EXTRATOR DE N√öCLEO GLOBAL (EVOLU√çDO)
# ==========================================================

from collections import defaultdict
import random
from src.db.memoria_sqlite import carregar_jogos_memoria
from src.db.memoria_sqlite import carregar_frequencia_dezenas

PESOS = {
    11: 1.0,
    12: 2.0,
    13: 4.0,
    14: 6.0,
}

UNIVERSO = list(range(1, 26))


def extrair_nucleo_global():
    """
    Retorna:
    - nucleo: dezenas mais fortes
    - satelites: dezenas boas
    - descartaveis: dezenas fracas
    """

    jogos = carregar_jogos_memoria()  # [(dezenas, pontos), ...]
    score = defaultdict(float)

    for dezenas, pontos in jogos:
        if pontos not in PESOS:
            continue

        peso = PESOS[pontos]
        for d in dezenas:
            score[int(d)] += peso

    if not score:
        return {"nucleo": [], "satelites": [], "descartaveis": []}

    ordenadas = sorted(score.items(), key=lambda x: x[1], reverse=True)
    dezenas_ordenadas = [d for d, _ in ordenadas]

    return {
        "nucleo": dezenas_ordenadas[:6],
        "satelites": dezenas_ordenadas[6:14],
        "descartaveis": dezenas_ordenadas[14:]
    }


# ==========================================================
# üöÄ NOVO: GERADOR DE BASE 18 USANDO O N√öCLEO
# ==========================================================

def gerar_base_18_nucleo():
    """
    Gera uma base 18 de alt√≠ssima qualidade usando:
    - n√∫cleo vencedor
    - sat√©lites
    - frequ√™ncia hist√≥rica
    - diversidade controlada
    """

    estrutura = extrair_nucleo_global()
    freq = carregar_frequencia_dezenas() or {}

    base = set()

    # 1Ô∏è‚É£ N√∫cleo (prioridade m√°xima)
    base.update(estrutura["nucleo"])

    # 2Ô∏è‚É£ Sat√©lites
    if len(base) < 12:
        faltam = 12 - len(base)
        base.update(estrutura["satelites"][:faltam])

    # 3Ô∏è‚É£ Frequ√™ncia hist√≥rica
    ordenadas_freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)
    for d, _ in ordenadas_freq:
        if len(base) >= 18:
            break
        base.add(int(d))

    # 4Ô∏è‚É£ Diversidade (anti-v√≠cio)
    if len(base) < 18:
        restantes = list(set(UNIVERSO) - base)
        base.update(random.sample(restantes, 18 - len(base)))

    return sorted(base)


================================================================================
üìÑ ARQUIVO: .\src\engine\fechamento_automatico.py
================================================================================

# ==========================================================
# üéØ FECHAMENTO AUTOM√ÅTICO INTELIGENTE
# ==========================================================

import itertools


def gerar_fechamento(base, tamanho_jogo=15, max_jogos=100):
    combinacoes = itertools.combinations(base, tamanho_jogo)

    jogos = []
    for comb in combinacoes:
        jogos.append(list(comb))
        if len(jogos) >= max_jogos:
            break

    return jogos


================================================================================
üìÑ ARQUIVO: .\src\engine\filtro_elite.py
================================================================================

import json
import os

ARQ_CALIBRACAO = "src/engine/calibracao_elite.json"


def carregar_calibracao():
    if not os.path.exists(ARQ_CALIBRACAO):
        return None
    with open(ARQ_CALIBRACAO, "r", encoding="utf-8") as f:
        return json.load(f)


def passa_filtro_elite(jogo, dezenas_quentes, dezenas_frias, ultimo_resultado):
    calibracao = carregar_calibracao()

    quentes = len(set(jogo) & set(dezenas_quentes))
    frias = len(set(jogo) & set(dezenas_frias))
    repetidas = len(set(jogo) & set(ultimo_resultado))
    pares = sum(1 for n in jogo if n % 2 == 0)
    soma = sum(jogo)

    # üîÅ MODO ANTIGO (fallback)
    if not calibracao:
        return (
            6 <= quentes <= 10 and
            3 <= frias <= 6 and
            6 <= repetidas <= 11 and
            6 <= pares <= 9
        )

    # üß† MODO CALIBRADO
    regras = {
        "quentes": quentes,
        "frias": frias,
        "repetidas": repetidas,
        "pares": pares,
        "soma": soma
    }

    for chave, valor in regras.items():
        cfg = calibracao.get(chave)
        if not cfg:
            continue
        if valor < cfg["min"] or valor > cfg["max"]:
            return False

    return True


================================================================================
üìÑ ARQUIVO: .\src\engine\filtro_identidade.py
================================================================================

"""
üß† FILTRO DE IDENTIDADE HIST√ìRICA
Evita repeti√ß√£o exata de concursos passados
e aplica penaliza√ß√£o suave por similaridade extrema.
"""

def jogo_identico_ao_passado(jogo, historico_resultados):
    """
    Retorna True se o jogo for ID√äNTICO
    a qualquer concurso passado (ordem ignorada).
    """
    jogo_set = set(jogo)

    for dezenas in historico_resultados:
        if jogo_set == set(dezenas):
            return True

    return False


def penalidade_similaridade(jogo, historico_resultados):
    """
    Calcula penalidade de score baseada
    na maior similaridade com concursos passados.

    N√ÉO BLOQUEIA, apenas penaliza.
    """
    jogo_set = set(jogo)
    max_repeticao = 0

    for dezenas in historico_resultados:
        repetidas = len(jogo_set & set(dezenas))
        if repetidas > max_repeticao:
            max_repeticao = repetidas

    # Penalidade inteligente (repuls√£o suave)
    if max_repeticao == 15:
        return -9999  # bloqueio total (imposs√≠vel)
    elif max_repeticao == 14:
        return -15
    elif max_repeticao == 13:
        return -8
    elif max_repeticao == 12:
        return -3
    else:
        return 0


def validar_jogo_historico(jogo, historico_resultados):
    """
    Retorna:
    - valido (bool)
    - penalidade (int)
    """
    if jogo_identico_ao_passado(jogo, historico_resultados):
        return False, -9999

    penalidade = penalidade_similaridade(jogo, historico_resultados)
    return True, penalidade


================================================================================
üìÑ ARQUIVO: .\src\engine\gerador_final.py
================================================================================

# ==========================================================
# üéØ GERADOR FINAL DE JOGOS ‚Äî MODO PRODU√á√ÉO
# ==========================================================

import random

from src.engine.aprendiz import obter_perfil_vencedor
from src.db.memoria_sqlite import carregar_frequencia_dezenas
from src.engine.filtro_elite import passa_filtro_elite
from src.engine.score_elite import calcular_score_elite

# ----------------------------------------------------------
# CONFIGURA√á√ïES
# ----------------------------------------------------------

UNIVERSO = list(range(1, 26))

TOTAL_JOGOS_15 = 10
TOTAL_JOGOS_18 = 7
TENTATIVAS_MAX = 500


# ----------------------------------------------------------
# GERADOR BASE (ROBUSTO)
# ----------------------------------------------------------

def gerar_jogo_custom(tamanho):
    perfil = obter_perfil_vencedor()
    freq = carregar_frequencia_dezenas()

    jogo = set()

    # üîπ Perfil vencedor (at√© 40%)
    if perfil:
        qtd = min(int(tamanho * 0.4), len(perfil))
        jogo.update(random.sample(perfil, qtd))

    # üîπ Frequ√™ncia hist√≥rica
    if freq:
        ordenadas = sorted(freq.items(), key=lambda x: x[1], reverse=True)
        frequentes = [int(n) for n, _ in ordenadas]

        restantes = tamanho - len(jogo)
        if restantes > 0:
            jogo.update(random.sample(frequentes, min(restantes, len(frequentes))))

    # üîπ Aleat√≥rio controlado
    restantes = tamanho - len(jogo)
    if restantes > 0:
        pool = list(set(UNIVERSO) - jogo)
        jogo.update(random.sample(pool, restantes))

    return sorted(jogo)


# ----------------------------------------------------------
# GERADOR FINAL + FILTRO ELITE
# ----------------------------------------------------------

def gerar_jogos_finais(dezenas_quentes, dezenas_frias, ultimo_resultado):
    """
    Gera jogos finais filtrados e ranqueados
    """

    jogos_15 = []
    jogos_18 = []

    perfil = obter_perfil_vencedor()

    # ===============================
    # üéØ JOGOS DE 15 DEZENAS
    # ===============================
    candidatos_15 = []
    tentativas = 0

    while len(candidatos_15) < 50 and tentativas < TENTATIVAS_MAX:
        jogo = gerar_jogo_custom(15)

        if passa_filtro_elite(jogo, dezenas_quentes, dezenas_frias, ultimo_resultado):
            score = calcular_score_elite(
                jogo,
                dezenas_quentes,
                dezenas_frias,
                ultimo_resultado,
                perfil
            )
            candidatos_15.append((score, jogo))

        tentativas += 1

    candidatos_15.sort(reverse=True)
    jogos_15 = [j for _, j in candidatos_15[:TOTAL_JOGOS_15]]

    # ===============================
    # üéØ JOGOS DE 18 DEZENAS
    # ===============================
    candidatos_18 = []
    tentativas = 0

    while len(candidatos_18) < 40 and tentativas < TENTATIVAS_MAX:
        jogo = gerar_jogo_custom(18)

        if passa_filtro_elite(jogo, dezenas_quentes, dezenas_frias, ultimo_resultado):
            score = calcular_score_elite(
                jogo,
                dezenas_quentes,
                dezenas_frias,
                ultimo_resultado,
                perfil
            )
            candidatos_18.append((score, jogo))

        tentativas += 1

    candidatos_18.sort(reverse=True)
    jogos_18 = [j for _, j in candidatos_18[:TOTAL_JOGOS_18]]

    return jogos_15, jogos_18


================================================================================
üìÑ ARQUIVO: .\src\engine\gerador_inteligente.py
================================================================================

import json
import random

ARQUIVO_PERFIL = "src/memory/perfil_vencedor.json"

def gerar_jogo_inteligente():
    with open(ARQUIVO_PERFIL, "r", encoding="utf-8") as f:
        perfil = json.load(f)

    freq = perfil["frequencia_dezenas"]
    dezenas = list(range(1, 26))

    pesos = [freq.get(str(d), 1) for d in dezenas]

    jogo = random.choices(dezenas, weights=pesos, k=15)
    return sorted(set(jogo))[:15]


================================================================================
üìÑ ARQUIVO: .\src\engine\gerador_jogos.py
================================================================================

"""
üß† GERADOR CENTRAL DE JOGOS ‚Äî IA SELETIVA
Gera√ß√£o extrema baseada em aprendizado + mem√≥ria + anti-caos.
"""

import random
from typing import List

from src.engine.seletor_extremo import selecionar_top_jogos
from src.engine.estatisticas import calcular_dezenas_quentes_frias
from src.engine.motor_multicerebro import obter_total_dezenas_atual
from src.engine.aprendiz import obter_perfil_vencedor
from src.utils.dados import carregar_resultados
from src.utils.logger import logger


# ==================================================
# ‚öôÔ∏è CONFIGURA√á√ÉO GLOBAL
# ==================================================
TOTAL_GERADOS = 500
TOP_15 = 10
TOP_18 = 7

DEZENAS_TOTAIS = list(range(1, 26))


# ==================================================
# üéØ GERADOR BASE (ANTI-CAOS)
# ==================================================
def gerar_jogo_base(
    tamanho: int,
    dezenas_quentes: List[int],
    dezenas_frias: List[int],
    ultimo_resultado: List[int]
) -> List[int]:

    jogo = set()

    # üî• Quentes dominam, mas n√£o totalizam
    alvo_quentes = int(tamanho * 0.45)
    while len(jogo) < alvo_quentes:
        jogo.add(random.choice(dezenas_quentes))

    # ‚ôªÔ∏è Repeti√ß√£o leve do √∫ltimo concurso
    repetidas = random.sample(
        ultimo_resultado,
        k=min(4, len(ultimo_resultado))
    )
    jogo.update(repetidas)

    # ‚ùÑÔ∏è Frias entram pouco
    if random.random() < 0.2:
        jogo.add(random.choice(dezenas_frias))

    # üé≤ Completa com diversidade
    while len(jogo) < tamanho:
        jogo.add(random.choice(DEZENAS_TOTAIS))

    return sorted(jogo)


# ==================================================
# üöÄ SUPERGERA√á√ÉO CONTROLADA
# ==================================================
def supergerar_jogos(
    tamanho: int,
    total: int
) -> List[List[int]]:

    dezenas_quentes, dezenas_frias = calcular_dezenas_quentes_frias()
    resultados = carregar_resultados()
    ultimo_resultado = resultados[-1]["dezenas"]

    jogos = set()

    logger.info(f"üß† Supergera√ß√£o iniciada | {total} jogos ({tamanho} dezenas)")

    tentativas = 0
    while len(jogos) < total and tentativas < total * 5:
        jogo = tuple(
            gerar_jogo_base(
                tamanho,
                dezenas_quentes,
                dezenas_frias,
                ultimo_resultado
            )
        )
        jogos.add(jogo)
        tentativas += 1

        if len(jogos) % 100 == 0:
            logger.debug(f"üß† Supergera√ß√£o: {len(jogos)}/{total}")

    return [list(j) for j in jogos]


# ==================================================
# üß† GERADOR FINAL INTELIGENTE
# ==================================================
def gerar_jogos_inteligentes():

    print("\nüß† GERANDO JOGOS COM IA SELETIVA ‚Äî N√çVEL EXTREMO\n")

    perfil = obter_perfil_vencedor()
    if not perfil:
        print("‚ùå Nenhum aprendizado encontrado. Execute o treinamento.")
        return

    dezenas_motor = obter_total_dezenas_atual()
    logger.info(f"üß† Motor ativo com {dezenas_motor} dezenas")

    # ===============================
    # üéØ JOGOS 15
    # ===============================
    jogos_15_brutos = supergerar_jogos(15, TOTAL_GERADOS)

    jogos_15_finais = selecionar_top_jogos(
        jogos_15_brutos,
        top_n=TOP_15,
        timeout_segundos=8
    )

    # ===============================
    # üéØ JOGOS 18
    # ===============================
    jogos_18_brutos = supergerar_jogos(18, TOTAL_GERADOS)

    jogos_18_finais = selecionar_top_jogos(
        jogos_18_brutos,
        top_n=TOP_18,
        timeout_segundos=8
    )

    # ===============================
    # üìä SA√çDA
    # ===============================
    print("=" * 60)
    print("üéØ TOP JOGOS ‚Äî 15 DEZENAS\n")

    for i, jogo in enumerate(jogos_15_finais, 1):
        print(f"Jogo {i:02d}: {jogo}")

    print("\n" + "=" * 60)
    print("üéØ TOP JOGOS ‚Äî 18 DEZENAS\n")

    for i, jogo in enumerate(jogos_18_finais, 1):
        print(f"Jogo {i:02d}: {jogo}")

    print("\n‚úÖ Jogos escolhidos por IA seletiva (anti-caos real)\n")


# ==================================================
# ‚ñ∂Ô∏è EXECU√á√ÉO
# ==================================================
if __name__ == "__main__":
    gerar_jogos_inteligentes()


================================================================================
üìÑ ARQUIVO: .\src\engine\memoria.py
================================================================================

import sqlite3
from pathlib import Path

DB_PATH = Path("data/lotofacil.db")

def inicializar_memoria():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    cur.execute("""
        CREATE TABLE IF NOT EXISTS memoria_premiada (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            concurso_previsto INTEGER,
            pontos INTEGER,
            jogo TEXT
        )
    """)

    conn.commit()
    conn.close()


def salvar_jogo_premiado(concurso_previsto, jogo, pontos):
    if pontos < 11:
        return  # REGRA DE OURO

    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    cur.execute("""
        INSERT INTO memoria_premiada (concurso_previsto, pontos, jogo)
        VALUES (?, ?, ?)
    """, (
        concurso_previsto,
        pontos,
        ",".join(map(str, jogo))
    ))

    conn.commit()
    conn.close()


def listar_melhores(min_pontos=11):
    inicializar_memoria()  # üî• GARANTE QUE A TABELA EXISTE

    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    cur.execute("""
        SELECT concurso_previsto, pontos, jogo
        FROM memoria_premiada
        WHERE pontos >= ?
        ORDER BY pontos DESC
    """, (min_pontos,))

    resultados = cur.fetchall()
    conn.close()

    return resultados


================================================================================
üìÑ ARQUIVO: .\src\engine\metrics.py
================================================================================

def exibir_resumo(concurso, pontos, score):
    print(f"üéØ Resultado concurso {concurso}")
    print(f"   ‚ûú Pontos: {pontos}")
    print(f"   ‚ûú Score : {round(score, 2)}")


================================================================================
üìÑ ARQUIVO: .\src\engine\motor_multicerebro.py
================================================================================

import random
from src.db.memoria_sqlite import carregar_frequencia_dezenas
from src.engine.aprendiz import obter_perfil_vencedor
from src.engine.extrator_nucleo import extrair_nucleo_global, gerar_base_18_nucleo
from src.engine.cerebro_neural import avaliar_base
from src.engine.fechamento_automatico import gerar_fechamento

# ==================================
# üéõÔ∏è CONFIGURA√á√ÉO DE TREINAMENTO
# ==================================

# Modo autom√°tico: escolhe aleatoriamente a quantidade de dezenas
MODO_TOTAL_DEZENAS_AUTOMATICO = True # ATIVAR MODO AUTOMATICO
#MODO_TOTAL_DEZENAS_AUTOMATICO = False # DESATIVAR MOVO AUTOMATICO

# Se autom√°tico estiver desligado, usa este valor fixo
TOTAL_DEZENAS_FIXO = 18

# TOTAL DE DEZENAS ATUAL (din√¢mico)
TOTAL_DEZENAS = TOTAL_DEZENAS_FIXO

# Intervalo permitido quando autom√°tico
#INTERVALO_DEZENAS = [15, 16, 17, 18, 19, 20]
INTERVALO_DEZENAS = [16, 17, 18, 19, 20]

UNIVERSO = list(range(1, 26))

MAX_PERFIL = 6
MIN_NUCLEO = 4
MAX_FREQ_DOMINANCIA = 10


def resolver_total_dezenas():
    """
    Decide quantas dezenas o motor vai usar neste ciclo.
    N√£o afeta fechamento nem gera√ß√£o final.
    """
    if MODO_TOTAL_DEZENAS_AUTOMATICO:
        return random.choice(INTERVALO_DEZENAS)
    return TOTAL_DEZENAS_FIXO



def gerar_jogo():
    global TOTAL_DEZENAS
    TOTAL_DEZENAS = resolver_total_dezenas()

    perfil = obter_perfil_vencedor() or []
    freq_dict = carregar_frequencia_dezenas() or {}
    nucleo_data = extrair_nucleo_global()

    nucleo = nucleo_data.get("nucleo", [])
    satelites = nucleo_data.get("satelites", [])

    jogo = set()

    # ===============================
    # 1Ô∏è‚É£ N√öCLEO GLOBAL
    # ===============================
    if nucleo:
        jogo.update(random.sample(nucleo, min(4, len(nucleo))))

    # ===============================
    # 2Ô∏è‚É£ PERFIL VENCEDOR
    # ===============================
    perfil_filtrado = list(set(perfil) - jogo)
    if perfil_filtrado:
        jogo.update(random.sample(perfil_filtrado, min(MAX_PERFIL, len(perfil_filtrado))))

    # ===============================
    # 3Ô∏è‚É£ SAT√âLITES
    # ===============================
    restantes = TOTAL_DEZENAS - len(jogo)
    if restantes > 0 and satelites:
        pool = list(set(satelites) - jogo)
        jogo.update(random.sample(pool, min(restantes, len(pool))))

    # ===============================
    # 4Ô∏è‚É£ FREQU√äNCIA HIST√ìRICA
    # ===============================
    if freq_dict:
        ordenadas = sorted(freq_dict.items(), key=lambda x: x[1], reverse=True)
        top_freq = [int(d) for d, _ in ordenadas[:MAX_FREQ_DOMINANCIA]]

        restantes = TOTAL_DEZENAS - len(jogo)
        pool = list(set(top_freq) - jogo)
        if restantes > 0 and pool:
            jogo.update(random.sample(pool, min(restantes, len(pool))))

    # ===============================
    # 5Ô∏è‚É£ ALEATORIEDADE FINAL
    # ===============================
    restantes = TOTAL_DEZENAS - len(jogo)
    if restantes > 0:
        pool = list(set(UNIVERSO) - jogo)
        jogo.update(random.sample(pool, restantes))

    return sorted(jogo)




# ==================================
# üéõÔ∏è PAR√ÇMETROS
# ==================================
TAMANHO_JOGO_FINAL = 15


def gerar_jogo_inteligente():
    # 1Ô∏è‚É£ GERAR BASE 18
    base = gerar_base_18_nucleo()

    # 2Ô∏è‚É£ CONSULTAR C√âREBRO NEURAL (consultivo)
    avaliacao = avaliar_base(base)

    if not avaliacao.get("aprovado", True):
        base = gerar_base_18_nucleo()

    # 3Ô∏è‚É£ GERAR FECHAMENTO
    jogos = gerar_fechamento(base, TAMANHO_JOGO_FINAL)

    return {
        "base_18": base,
        "avaliacao": avaliacao,
        "jogos": jogos
    }

def obter_total_dezenas_atual():
    """
    Retorna quantas dezenas o motor usou no √∫ltimo ciclo.
    """
    return TOTAL_DEZENAS


================================================================================
üìÑ ARQUIVO: .\src\engine\nn_cerebro.py
================================================================================

# src/engine/nn_cerebro.py

import joblib
import numpy as np

class CerebroNeural:

    def __init__(self, modelo_path="data/modelo_nn.pkl"):
        self.modelo = joblib.load(modelo_path)

    def avaliar_jogo(self, features: dict) -> float:
        ordem = [
            "soma", "pares", "impares", "repeticao_anterior",
            "perc_perfil", "freq_media", "dispersao", "entropia"
        ]

        vetor = np.array([[features[k] for k in ordem]])
        score = self.modelo.predict_proba(vetor)[0][1]
        return round(float(score), 4)


================================================================================
üìÑ ARQUIVO: .\src\engine\scorer.py
================================================================================

from src.engine.brains.brain_patterns import score_padroes
from src.engine.brains.brain_diversity import diversidade


def score_total(base, outras, pontos_reais, score_heuristico):
    score = 0
    score += pontos_reais * 10
    score += score_heuristico * 2
    score += score_padroes(base)
    score += diversidade(base, outras)
    return score


================================================================================
üìÑ ARQUIVO: .\src\engine\score_1415.py
================================================================================

"""
üéØ SCORE 14/15
Calcula um score num√©rico de proximidade estat√≠stica
com base em mem√≥ria, estat√≠stica e anti-caos.
"""

from collections import Counter

from src.engine.filtro_identidade import validar_jogo_historico


def score_memoria(jogo, memoria_1415):
    """
    Mede o quanto o jogo se parece com jogos 14/15 j√° memorizados.
    """
    if not memoria_1415:
        return 0

    jogo_set = set(jogo)
    soma = 0

    for jogo_mem in memoria_1415:
        intersecao = len(jogo_set & set(jogo_mem))
        soma += intersecao

    return soma / len(memoria_1415)


def score_estatistico(jogo, dezenas_quentes, dezenas_frias):
    """
    Score baseado em dezenas quentes e frias
    (vi√©s controlado, n√£o extremo).
    """
    quentes = len(set(jogo) & set(dezenas_quentes))
    frias = len(set(jogo) & set(dezenas_frias))

    return (quentes * 2) - (frias * 1)


def score_estrutura(jogo):
    """
    Avalia estrutura interna do jogo:
    - Pares / √≠mpares
    - Distribui√ß√£o baixa/alta
    """
    pares = sum(1 for d in jogo if d % 2 == 0)
    impares = len(jogo) - pares

    baixos = sum(1 for d in jogo if d <= 12)
    altos = len(jogo) - baixos

    score = 0

    # equil√≠brio estrutural
    if 6 <= pares <= 9:
        score += 3
    if 6 <= baixos <= 9:
        score += 3

    return score


def calcular_score_1415(
    jogo,
    memoria_1415,
    dezenas_quentes,
    dezenas_frias,
    historico_resultados
):
    """
    SCORE FINAL DE QUALIDADE 14/15
    """

    # ===============================
    # üö´ FILTRO HIST√ìRICO
    # ===============================
    valido, penalidade_hist = validar_jogo_historico(
        jogo, historico_resultados
    )

    if not valido:
        return -9999  # imposs√≠vel

    # ===============================
    # üß† SCORES PARCIAIS
    # ===============================
    s_memoria = score_memoria(jogo, memoria_1415)
    s_est = score_estatistico(jogo, dezenas_quentes, dezenas_frias)
    s_estr = score_estrutura(jogo)

    # ===============================
    # ‚öñÔ∏è SCORE FINAL
    # ===============================
    score_final = (
        (s_memoria * 1.5) +
        (s_est * 1.0) +
        (s_estr * 1.0) +
        penalidade_hist
    )

    return round(score_final, 2)


================================================================================
üìÑ ARQUIVO: .\src\engine\score_elite.py
================================================================================

from collections import Counter

def calcular_score_elite(
    jogo,
    dezenas_quentes,
    dezenas_frias,
    ultimo_resultado,
    perfil_vencedor
):
    score = 0

    jogo = set(jogo)
    ultimo = set(ultimo_resultado or [])
    perfil = set(perfil_vencedor or [])

    # ==================================================
    # üî• 1Ô∏è‚É£ N√öCLEO REPETIDO (MUITO IMPORTANTE)
    # ==================================================
    intersecao_ultimo = len(jogo & ultimo)

    if 8 <= intersecao_ultimo <= 10:
        score += 30
    elif 6 <= intersecao_ultimo <= 11:
        score += 15
    else:
        score -= 10

    # ==================================================
    # üî• 2Ô∏è‚É£ PERFIL VENCEDOR HIST√ìRICO
    # ==================================================
    score += len(jogo & perfil) * 3

    # ==================================================
    # üî• 3Ô∏è‚É£ DEZENAS QUENTES
    # ==================================================
    quentes = len(jogo & set(dezenas_quentes))
    score += quentes * 2.5

    # ==================================================
    # ‚öñÔ∏è 4Ô∏è‚É£ DEZENAS FRIAS (CONTROLE FINO)
    # ==================================================
    frias = len(jogo & set(dezenas_frias))

    if frias <= 2:
        score += 8
    elif frias <= 4:
        score += 2
    else:
        score -= 15

    # ==================================================
    # ‚öñÔ∏è 5Ô∏è‚É£ PARES / √çMPARES
    # ==================================================
    pares = len([n for n in jogo if n % 2 == 0])

    if 7 <= pares <= 8:
        score += 6
    elif 6 <= pares <= 9:
        score += 3
    else:
        score -= 5

    # ==================================================
    # ‚ùå 6Ô∏è‚É£ SEQU√äNCIAS LONGAS
    # ==================================================
    seq = 0
    max_seq = 0
    for n in sorted(jogo):
        if n - 1 in jogo:
            seq += 1
            max_seq = max(max_seq, seq)
        else:
            seq = 0

    if max_seq >= 4:
        score -= max_seq * 3

    return round(score, 2)



================================================================================
üìÑ ARQUIVO: .\src\engine\score_multicerebro.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\engine\seletor_extremo.py
================================================================================

"""
üî• SELETOR EXTREMO ‚Äî IA ANTI-CAOS
Elimina brutalmente jogos ruins e mant√©m
os mais alinhados com 14/15 pontos reais.
"""

from typing import List, Tuple
from time import time

from src.engine.score_1415 import calcular_score_1415
from src.engine.cerebros_memoria import obter_cerebros_memoria
from src.utils.dados import carregar_resultados
from src.utils.logger import logger


class SeletorExtremo:
    """
    Motor seletivo de alto n√≠vel.
    N√£o gera jogos ‚Äî apenas decide quais sobrevivem.
    """

    def __init__(
        self,
        top_n: int = 10,
        score_minimo: float = -999,
        timeout_segundos: int = 10
    ):
        self.top_n = top_n
        self.score_minimo = score_minimo
        self.timeout_segundos = timeout_segundos

        self.cerebros = obter_cerebros_memoria()
        self.historico = [
            r["dezenas"] for r in carregar_resultados()
        ]

    # --------------------------------------------------
    # üî• SELE√á√ÉO PRINCIPAL
    # --------------------------------------------------
    def selecionar(self, jogos):
        """
        Recebe lista de jogos e retorna os TOP N:
        [(jogo, score_final), ...]
        """

        inicio = time()
        avaliados = []

        total = len(jogos)
        logger.info(f"üß† Seletor extremo iniciado | Jogos recebidos: {total}")

        for idx, jogo in enumerate(jogos, start=1):
            # ‚è±Ô∏è Prote√ß√£o contra travamento
            if time() - inicio > self.timeout_segundos:
                logger.warning("‚è±Ô∏è Timeout atingido no seletor extremo")
                break

            # üî• SCORE √öNICO E OFICIAL
            score_final, detalhes = self.cerebros.score_final(jogo)

            if score_final >= self.score_minimo:
                avaliados.append((jogo, score_final))

            # Log leve
            if idx % 100 == 0 or idx == total:
                logger.debug(
                    f"üß† Avaliados: {idx}/{total} | "
                    f"Aprovados: {len(avaliados)}"
                )

        if not avaliados:
            logger.warning("‚ö†Ô∏è Nenhum jogo passou no filtro m√≠nimo")
            return []

        # üèÜ ORDENA√á√ÉO FINAL
        avaliados.sort(key=lambda x: x[1], reverse=True)
        selecionados = avaliados[: self.top_n]

        logger.info(
            f"‚úÖ Sele√ß√£o conclu√≠da | "
            f"Sobreviventes: {len(selecionados)} / {total}"
        )

        return selecionados



# --------------------------------------------------
# üöÄ FUN√á√ÉO DE ATALHO
# --------------------------------------------------
def selecionar_top_jogos(
    jogos: List[List[int]],
    top_n: int = 10,
    score_minimo: float = -999,
    timeout_segundos: int = 10
) -> List[List[int]]:

    seletor = SeletorExtremo(
        top_n=top_n,
        score_minimo=score_minimo,
        timeout_segundos=timeout_segundos
    )

    resultado = seletor.selecionar(jogos)
    return [jogo for jogo, _ in resultado]


================================================================================
üìÑ ARQUIVO: .\src\engine\seletor_jogos.py
================================================================================

# src/engine/seletor_jogos.py

from src.engine.motor_multicerebro import gerar_jogo
from src.engine.nn_cerebro import CerebroNeural
from src.utils.extrator_features import extrair_features
import random

class SeletorJogos:

    def __init__(self, usar_nn=True):
        self.usar_nn = usar_nn
        self.nn = CerebroNeural() if usar_nn else None

    def gerar_jogos_filtrados(self, total_gerados=30, total_selecionados=10):
        jogos = [gerar_jogo() for _ in range(total_gerados)]

        if not self.usar_nn:
            random.shuffle(jogos)
            return jogos[:total_selecionados]

        avaliados = []
        for jogo in jogos:
            features = extrair_features(jogo)
            score = self.nn.avaliar_jogo(features)
            avaliados.append((jogo, score))

        avaliados.sort(key=lambda x: x[1], reverse=True)

        # mant√©m diversidade (n√£o pega s√≥ o topo)
        melhores = avaliados[:total_selecionados * 2]
        random.shuffle(melhores)

        return [j[0] for j in melhores[:total_selecionados]]


================================================================================
üìÑ ARQUIVO: .\src\engine\trainer copy.py
================================================================================

from collections import Counter

from src.engine.motor_multicerebro import gerar_jogo, obter_total_dezenas_atual
from src.engine.aprendiz import gerar_perfil_vencedor
from src.engine.avaliador import Avaliador
from src.engine.estatisticas import calcular_dezenas_quentes_frias
from src.engine.gerador_final import gerar_jogos_finais
from src.engine.calibrador_pesos import calibrar_pesos

from src.db.memoria_sqlite import (
    salvar_jogo_premiado,
    carregar_jogos_premiados
)

from src.utils.comparador import contar_acertos
from src.utils.dados import carregar_resultados
from src.reports.relatorio_txt import salvar_relatorio

# ===============================
# ‚öôÔ∏è CONFIGURA√á√ÉO DE APRENDIZADO
# ===============================

APRENDIZADO_MULTIPLO = True

CONFIG_JOGOS_TREINO = {
    16: 5,   # 5 jogos de 16 dezenas
    18: 3,   # 3 jogos de 18 dezenas
    20: 2    # 2 jogos de 20 dezenas
}

MODO_FOCO_1415 = True



def treinar_sequencial():
    print("üß† Treinamento sequencial iniciado")

    # ===============================
    # üì• CARREGA RESULTADOS OFICIAIS
    # ===============================
    resultados = carregar_resultados()

    # Garantir ordem cronol√≥gica (antigo ‚Üí novo)
    resultados = sorted(resultados, key=lambda x: x["concurso"])

    avaliador = Avaliador()
    contador_dezenas = {}

    # ===============================
    # üìä HIST√ìRICO GLOBAL
    # ===============================
    historico_dezenas = []

    for i in range(len(resultados) - 1):
        concurso_atual = resultados[i]["concurso"]
        dezenas_atual = resultados[i]["dezenas"]
        dezenas_reais = resultados[i + 1]["dezenas"]

        historico_dezenas.append(dezenas_atual)

        # ===============================
        # üéì APRENDIZADO
        # ===============================
        if APRENDIZADO_MULTIPLO:
            for tamanho, quantidade in CONFIG_JOGOS_TREINO.items():
                for _ in range(quantidade):  
                    jogo = gerar_jogo()

                    pontos = contar_acertos(jogo, dezenas_reais)
                    avaliador.registrar(pontos)

                    total_dezenas_usadas = len(jogo)
                    contador_dezenas[total_dezenas_usadas] = (
                        contador_dezenas.get(total_dezenas_usadas, 0) + 1
                    )

                    print(
                        f"üìò Concurso {concurso_atual} ‚Üí previs√£o {concurso_atual + 1} | Pontos: {pontos}"
                    )

                    if pontos >= 11:
                        print("üí∞ JOGO PREMIADO! Salvando na mem√≥ria")
                        salvar_jogo_premiado(concurso_atual, jogo, pontos)

        else:
            jogo = gerar_jogo()
            pontos = contar_acertos(jogo, dezenas_reais)
            avaliador.registrar(pontos)

            total_dezenas_usadas = len(jogo)
            contador_dezenas[total_dezenas_usadas] = (
                contador_dezenas.get(total_dezenas_usadas, 0) + 1
            )

        print(
            f"üìò Concurso {concurso_atual} ‚Üí previs√£o {concurso_atual + 1} | Pontos: {pontos}"
        )

        if pontos >= 11:
            print("üí∞ JOGO PREMIADO! Salvando na mem√≥ria")
            salvar_jogo_premiado(concurso_atual, jogo, pontos)






        # üìä Controle de tamanho dos jogos
        total_dezenas_usadas = obter_total_dezenas_atual()
        contador_dezenas[total_dezenas_usadas] = (
            contador_dezenas.get(total_dezenas_usadas, 0) + 1
        )

        print(
            f"üìò Concurso {concurso_atual} ‚Üí previs√£o {concurso_atual + 1} | Pontos: {pontos}"
        )

        # üí∞ Salva mem√≥ria premiada (>=11)
        if pontos >= 11:
            print("üí∞ JOGO PREMIADO! Salvando na mem√≥ria")
            salvar_jogo_premiado(concurso_atual, jogo, pontos)

    # ===============================
    # üß† PERFIL VENCEDOR (como j√° existia)
    # ===============================
    gerar_perfil_vencedor()
    avaliador.relatorio()

    # ===============================
    # üî• ESTAT√çSTICAS REAIS DO HIST√ìRICO
    # ===============================
    dezenas_quentes, dezenas_frias = calcular_dezenas_quentes_frias()

    # √öltimo resultado conhecido
    ultimo_resultado = resultados[-1]["dezenas"]

    # ===============================
    # üß† CALIBRA√á√ÉO AUTOM√ÅTICA DE PESOS
    # ===============================
    jogos_1415 = carregar_jogos_premiados(min_pontos=14)

    if jogos_1415:
        pesos_calibrados = calibrar_pesos(jogos_1415)
        print("‚öôÔ∏è Pesos calibrados automaticamente:", pesos_calibrados)
    else:
        pesos_calibrados = None
        print("‚ö†Ô∏è Ainda n√£o h√° jogos 14/15 suficientes para calibra√ß√£o")

    # ===============================
    # üéØ GERA√á√ÉO FINAL DE JOGOS
    # ===============================
    jogos_15, jogos_18 = gerar_jogos_finais(
        dezenas_quentes=dezenas_quentes,
        dezenas_frias=dezenas_frias,
        ultimo_resultado=ultimo_resultado,
        pesos=pesos_calibrados  # ‚Üê NOVO (opcional e seguro)
    )

    # ===============================
    # üìÑ RELAT√ìRIO FINAL
    # ===============================
    estatisticas = avaliador.resumo()
    estatisticas["dezenas_treinamento"] = contador_dezenas

    relatorio_avaliador = avaliador.relatorio_texto()

    salvar_relatorio(
        jogos_15,
        jogos_18,
        estatisticas,
        relatorio_avaliador
    )

    print("‚úÖ Treinamento finalizado com sucesso")


================================================================================
üìÑ ARQUIVO: .\src\engine\trainer.py
================================================================================

from collections import Counter

from src.engine.motor_multicerebro import gerar_jogo
from src.engine.aprendiz import gerar_perfil_vencedor
from src.engine.avaliador import Avaliador
from src.engine.estatisticas import calcular_dezenas_quentes_frias
from src.engine.gerador_final import gerar_jogos_finais
from src.engine.calibrador_pesos import calibrar_pesos

from src.db.memoria_sqlite import (
    salvar_jogo_premiado,
    carregar_jogos_premiados
)

from src.utils.comparador import contar_acertos
from src.utils.dados import carregar_resultados
from src.reports.relatorio_txt import salvar_relatorio

from src.logger import log_treinamento

log_treinamento("üß† Treinamento iniciado")

# ===============================
# ‚öôÔ∏è CONFIGURA√á√ÉO DE APRENDIZADO
# ===============================

APRENDIZADO_MULTIPLO = True
MODO_FOCO_1415 = True  # ‚Üê ATIVO

CONFIG_JOGOS_TREINO = {
    16: 5,
    18: 3,
    20: 2
}

def treinar_sequencial():
    print("üß† Treinamento sequencial iniciado")

    resultados = carregar_resultados()
    resultados = sorted(resultados, key=lambda x: x["concurso"])

    avaliador = Avaliador()
    contador_dezenas = Counter()

    historico_dezenas = []

    # üî• BUFFER DE APRENDIZADO FOCO 14/15
    jogos_foco_1415 = []

    for i in range(len(resultados) - 1):
        concurso_atual = resultados[i]["concurso"]
        dezenas_atual = resultados[i]["dezenas"]
        dezenas_reais = resultados[i + 1]["dezenas"]

        historico_dezenas.append(dezenas_atual)

        # ===============================
        # üéì TREINO MULTIPLO CONTROLADO
        # ===============================
        if APRENDIZADO_MULTIPLO:
            for tamanho, quantidade in CONFIG_JOGOS_TREINO.items():
                for _ in range(quantidade):
                    jogo = gerar_jogo()

                    pontos = contar_acertos(jogo, dezenas_reais)
                    avaliador.registrar(pontos)

                    contador_dezenas[len(jogo)] += 1

                    # üíæ Mem√≥ria geral (>=11)
                    if pontos >= 11:
                        salvar_jogo_premiado(concurso_atual, jogo, pontos)

                    # üî• FOCO REAL 14/15 (aprendizado incremental)
                    if MODO_FOCO_1415 and pontos >= 14:
                        jogos_foco_1415.append({
                            "concurso": concurso_atual,
                            "jogo": jogo,
                            "pontos": pontos
                        })
                        log_treinamento(
                            f"üî• FOCO 14/15 | Concurso {concurso_atual} | Pontos: {pontos}"
                        )

                    log_treinamento(
                        f"Concurso {concurso_atual} | Pontos: {pontos} | Tamanho: {len(jogo)}"
                    )

        else:
            jogo = gerar_jogo()
            pontos = contar_acertos(jogo, dezenas_reais)

            avaliador.registrar(pontos)
            contador_dezenas[len(jogo)] += 1

            if pontos >= 11:
                salvar_jogo_premiado(concurso_atual, jogo, pontos)

        print(
            f"üìò Concurso {concurso_atual} ‚Üí previs√£o {concurso_atual + 1} | √öltimos pontos: {pontos}"
        )

    # ===============================
    # üî• CONSOLIDA APRENDIZADO 14/15
    # ===============================
    if jogos_foco_1415:
        for item in jogos_foco_1415:
            salvar_jogo_premiado(
                item["concurso"],
                item["jogo"],
                item["pontos"]
            )

        log_treinamento(
            f"üî• Total de jogos 14/15 aprendidos: {len(jogos_foco_1415)}"
        )

    # ===============================
    # üß† PERFIL VENCEDOR
    # ===============================
    gerar_perfil_vencedor()
    avaliador.relatorio()

    # ===============================
    # üî• ESTAT√çSTICAS REAIS
    # ===============================
    dezenas_quentes, dezenas_frias = calcular_dezenas_quentes_frias()
    ultimo_resultado = resultados[-1]["dezenas"]

    # ===============================
    # ‚öôÔ∏è CALIBRA√á√ÉO DE PESOS
    # ===============================
    jogos_1415 = carregar_jogos_premiados(min_pontos=14)

    if jogos_1415:
        pesos_calibrados = calibrar_pesos(jogos_1415)
        print("‚öôÔ∏è Pesos calibrados:", pesos_calibrados)
        log_treinamento("‚öôÔ∏è Pesos calibrados com jogos 14/15")
    else:
        pesos_calibrados = None
        print("‚ö†Ô∏è Sem jogos 14/15 suficientes")
        log_treinamento("‚ö†Ô∏è Sem jogos 14/15 para calibra√ß√£o")

    # ===============================
    # üéØ GERA√á√ÉO FINAL
    # ===============================
    jogos_15, jogos_18 = gerar_jogos_finais(
        dezenas_quentes=dezenas_quentes,
        dezenas_frias=dezenas_frias,
        ultimo_resultado=ultimo_resultado,
        pesos=pesos_calibrados
    )

    # ===============================
    # üìÑ RELAT√ìRIO
    # ===============================
    estatisticas = avaliador.resumo()
    estatisticas["dezenas_treinamento"] = dict(contador_dezenas)

    relatorio_avaliador = avaliador.relatorio_texto()

    salvar_relatorio(
        jogos_15,
        jogos_18,
        estatisticas,
        relatorio_avaliador
    )

    print("‚úÖ Treinamento finalizado com sucesso")


================================================================================
üìÑ ARQUIVO: .\src\engine\trainer_GITHUB.py
================================================================================

# ==========================================================
# üß† TREINAMENTO IA LOTOF√ÅCIL ‚Äî CHECKPOINT GIT ORGANIZADO
# ==========================================================

import subprocess
from datetime import datetime
from collections import Counter

from src.engine.motor_multicerebro import gerar_jogo
from src.engine.aprendiz import gerar_perfil_vencedor
from src.engine.avaliador import Avaliador
from src.engine.estatisticas import calcular_dezenas_quentes_frias
from src.engine.gerador_final import gerar_jogos_finais
from src.engine.calibrador_pesos import calibrar_pesos

from src.db.memoria_sqlite import (
    salvar_jogo_premiado,
    carregar_jogos_premiados
)

from src.utils.comparador import contar_acertos
from src.utils.dados import carregar_resultados
from src.reports.relatorio_txt import salvar_relatorio
from src.logger import log_treinamento

# ==========================================================
# üîî LOG INICIAL
# ==========================================================

log_treinamento("üß† Treinamento iniciado")

# ==========================================================
# ‚öôÔ∏è CONFIGURA√á√ÉO DE APRENDIZADO
# ==========================================================

APRENDIZADO_MULTIPLO = True
MODO_FOCO_1415 = True

CONFIG_JOGOS_TREINO = {
    16: 5,
    18: 3,
    20: 2
}

# ==========================================================
# üì§ CHECKPOINT GIT (SA√çDA CONTROLADA)
# ==========================================================

def git_checkpoint(concurso_atual):
    try:
        subprocess.run(
            ["git", "config", "--global", "user.name", "github-actions[bot]"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        subprocess.run(
            ["git", "config", "--global", "user.email", "github-actions[bot]@users.noreply.github.com"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )

        subprocess.run(
            ["git", "add", "."],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )

        diff = subprocess.run(
            ["git", "diff", "--cached", "--quiet"]
        )

        if diff.returncode != 0:
            mensagem_commit = (
                f"üß† Checkpoint autom√°tico | Concurso {concurso_atual} | "
                f"{datetime.now():%Y-%m-%d %H:%M:%S}"
            )

            commit = subprocess.run(
                ["git", "commit", "-m", mensagem_commit],
                capture_output=True,
                text=True
            )

            push = subprocess.run(
                ["git", "push"],
                capture_output=True,
                text=True
            )

            # ===============================
            # üì§ SA√çDA ORGANIZADA
            # ===============================
            print("\n" + "=" * 50)
            print("üì§ COMMIT REALIZADO NO GITHUB")
            print(mensagem_commit)
            print("=" * 50 + "\n")

            log_treinamento(f"üì§ Git push realizado | Concurso {concurso_atual}")

        else:
            print("\n" + "=" * 50)
            print("üì≠ NENHUMA ALTERA√á√ÉO PARA COMMIT")
            print("=" * 50 + "\n")

            log_treinamento("üì≠ Nenhuma altera√ß√£o para commit")

    except Exception as e:
        print("\n" + "=" * 50)
        print("‚ùå ERRO NO CHECKPOINT GIT")
        print(str(e))
        print("=" * 50 + "\n")

        log_treinamento(f"‚ùå Erro no checkpoint Git: {e}")

# ==========================================================
# üß† TREINAMENTO SEQUENCIAL
# ==========================================================

def treinar_sequencial():
    print("üß† Treinamento sequencial iniciado\n")

    resultados = carregar_resultados()
    resultados = sorted(resultados, key=lambda x: x["concurso"])

    avaliador = Avaliador()
    contador_dezenas = Counter()
    jogos_foco_1415 = []

    for i in range(len(resultados) - 1):
        concurso_atual = resultados[i]["concurso"]
        dezenas_reais = resultados[i + 1]["dezenas"]

        if APRENDIZADO_MULTIPLO:
            for tamanho, quantidade in CONFIG_JOGOS_TREINO.items():
                for _ in range(quantidade):
                    jogo = gerar_jogo()
                    pontos = contar_acertos(jogo, dezenas_reais)

                    avaliador.registrar(pontos)
                    contador_dezenas[len(jogo)] += 1

                    if pontos >= 11:
                        salvar_jogo_premiado(concurso_atual, jogo, pontos)

                    if MODO_FOCO_1415 and pontos >= 14:
                        jogos_foco_1415.append({
                            "concurso": concurso_atual,
                            "jogo": jogo,
                            "pontos": pontos
                        })

                    log_treinamento(
                        f"Concurso {concurso_atual} | Pontos: {pontos} | Tamanho: {len(jogo)}"
                    )

        print(
            f"üìò Concurso {concurso_atual} ‚Üí previs√£o {concurso_atual + 1} | "
            f"√öltimos pontos: {pontos}"
        )

        # üöÄ CHECKPOINT GIT
        git_checkpoint(concurso_atual)

    print("\n‚úÖ Treinamento finalizado com sucesso")

# ==========================================================
# ‚ñ∂Ô∏è EXECU√á√ÉO
# ==========================================================

if __name__ == "__main__":
    treinar_sequencial()


================================================================================
üìÑ ARQUIVO: .\src\engine\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\engine\brains\brain_diversity.py
================================================================================

def diversidade(base, outras):
    score = 0
    for b in outras:
        inter = len(base & b)
        score -= inter * 2
    return score


================================================================================
üìÑ ARQUIVO: .\src\engine\brains\brain_explorer.py
================================================================================

import random

def gerar_base_exploracao(todas, tamanho=18):
    return set(random.sample(todas, tamanho))


================================================================================
üìÑ ARQUIVO: .\src\engine\brains\brain_patterns.py
================================================================================

PRIMOS = {2,3,5,7,11,13,17,19,23}
FIBO = {1,2,3,5,8,13,21}

def contar_padroes(base):
    return {
        "impares": sum(1 for n in base if n % 2 == 1),
        "primos": sum(1 for n in base if n in PRIMOS),
        "fibo": sum(1 for n in base if n in FIBO)
    }

def score_padroes(base):
    p = contar_padroes(base)
    score = 0

    if 8 <= p["impares"] <= 9:
        score += 3
    if 5 <= p["primos"] <= 6:
        score += 3
    if 3 <= p["fibo"] <= 5:
        score += 2

    return score


================================================================================
üìÑ ARQUIVO: .\src\engine\brains\brain_stats.py
================================================================================

import random

def gerar_base_stats(freq_rank, tamanho=18):
    return set(freq_rank[:tamanho])


================================================================================
üìÑ ARQUIVO: .\src\engine\brains\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\experimental\extrator_insights.py
================================================================================

# src/experimental/extrator_insights.py

import json
import statistics
from collections import Counter

class ExtratorInsights:

    def __init__(self, jogos_premiados, perfil_vencedor):
        self.jogos = jogos_premiados
        self.perfil = set(perfil_vencedor)

    def extrair(self):
        somas = []
        pares = []
        repeticoes = []
        uso_perfil = []

        for jogo in self.jogos:
            soma = sum(jogo)
            qtd_pares = sum(1 for d in jogo if d % 2 == 0)
            repeticao = len(set(jogo) & self.perfil)
            perc_perfil = repeticao / len(jogo)

            somas.append(soma)
            pares.append(qtd_pares)
            repeticoes.append(repeticao)
            uso_perfil.append(perc_perfil)

        return {
            "faixa_soma": [
                int(statistics.mean(somas) - statistics.stdev(somas)),
                int(statistics.mean(somas) + statistics.stdev(somas))
            ],
            "media_pares": round(statistics.mean(pares), 2),
            "media_repeticao_perfil": round(statistics.mean(repeticoes), 2),
            "percentual_medio_perfil": round(statistics.mean(uso_perfil), 2),
            "total_jogos_analisados": len(self.jogos)
        }

    def salvar(self, caminho):
        dados = self.extrair()
        with open(caminho, "w", encoding="utf-8") as f:
            json.dump(dados, f, indent=4)


================================================================================
üìÑ ARQUIVO: .\src\experimental\treinar_nn.py
================================================================================

# src/experimental/treinar_nn.py

import joblib
import numpy as np
from sklearn.neural_network import MLPClassifier
from src.db.memoria_sqlite import carregar_memoria_completa
from src.utils.extrator_features import extrair_features

def carregar_dados_treino():
    X = []
    y = []

    registros = carregar_memoria_completa()  
    # deve retornar: concurso, dezenas, pontos

    for concurso, dezenas, pontos in registros:
        features = extrair_features(dezenas)

        X.append(list(features.values()))
        y.append(1 if pontos >= 11 else 0)

    return np.array(X), np.array(y)

def treinar_nn():
    X, y = carregar_dados_treino()

    if len(X) < 50:
        print("‚ùå Dados insuficientes para treinar a rede neural")
        return

    modelo = MLPClassifier(
        hidden_layer_sizes=(16, 8),
        activation="relu",
        solver="adam",
        max_iter=500,
        random_state=42
    )

    modelo.fit(X, y)

    joblib.dump(modelo, "data/modelo_nn.pkl")
    print("‚úÖ Modelo neural treinado e salvo com sucesso")

if __name__ == "__main__":
    treinar_nn()


================================================================================
üìÑ ARQUIVO: .\src\experimentos\laboratorio_inteligente.py
================================================================================

import os
import csv
import datetime
import statistics
from collections import Counter

from src.engine.motor_multicerebro import gerar_jogo
from src.engine.avaliador import Avaliador
from src.db.memoria_sqlite import carregar_jogos_memoria

# ===============================
# üî¢ CONTADOR DE ACERTOS (LOCAL)
# ===============================
def contar_acertos(jogo, concurso):
    return len(set(jogo) & set(concurso))


# ===============================
# üß† NN CONSULTIVA (OPCIONAL)
# ===============================
try:
    from src.engine.cerebro_neural import avaliar_ciclo
    NN_ATIVA = True
except ImportError:
    NN_ATIVA = False


# ===============================
# üìÅ PASTA DE RELAT√ìRIOS
# ===============================
BASE_DIR = os.path.dirname(__file__)
RELATORIOS_DIR = os.path.join(BASE_DIR, "relatorios")
os.makedirs(RELATORIOS_DIR, exist_ok=True)

DATA_TAG = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")


# ===============================
# üéõÔ∏è ESTRAT√âGIAS
# ===============================
ESTRATEGIAS = [
    {"nome": "padrao", "usar_nn": False},
    {"nome": "nucleo_forte", "usar_nn": False},
    {"nome": "nn_consultiva", "usar_nn": True},
]

CICLOS = 50
LIMITE_OVERFITTING = 0.70


# ===============================
# üîÅ EXECUTAR CICLO
# ===============================
def executar_ciclo(concursos):
    pontos = []
    dezenas_usadas = Counter()
    avaliador = Avaliador()

    for concurso_real in concursos:
        jogo = gerar_jogo()
        p = contar_acertos(jogo, concurso_real)

        pontos.append(p)
        avaliador.registrar(p)

        if p >= 11:
            dezenas_usadas.update(jogo)

    return pontos, dezenas_usadas, avaliador


# ===============================
# üìä M√âTRICAS
# ===============================
def coletar_metricas(pontos):
    return {
        "media": statistics.mean(pontos),
        "taxa_11": sum(1 for p in pontos if p >= 11) / len(pontos),
        "desvio": statistics.pstdev(pontos),
    }


# ===============================
# üö® OVERFITTING
# ===============================
def detectar_overfitting(metricas, dezenas_usadas):
    if metricas["taxa_11"] > LIMITE_OVERFITTING:
        return True

    if dezenas_usadas:
        top = dezenas_usadas.most_common(5)
        concentracao = sum(v for _, v in top) / sum(dezenas_usadas.values())
        if concentracao > 0.45:
            return True

    return False


# ===============================
# üß™ LABORAT√ìRIO
# ===============================
def executar_laboratorio():
    memoria = carregar_jogos_memoria()
    concursos = [j for j, _ in memoria[-500:]]

    ranking = []
    relatorio_txt = []

    print(f"üì¶ Concursos usados no laborat√≥rio: {len(concursos)}\n")

    for estrategia in ESTRATEGIAS:
        print(f"\nüî¨ Testando estrat√©gia: {estrategia['nome']}")
        print("-" * 40)

        medias = []
        taxas = []

        ciclos_validos = 0
        ciclos_descartados = 0

        for ciclo in range(1, CICLOS + 1):
            pontos, dezenas, _ = executar_ciclo(concursos)
            metricas = coletar_metricas(pontos)

            # üß† Avalia√ß√£o NN
            if estrategia["usar_nn"] and NN_ATIVA:
                score_nn = avaliar_ciclo(pontos)
                if score_nn < 0.5:
                    ciclos_descartados += 1
                    print(f"  ‚ö†Ô∏è Ciclo {ciclo}/{CICLOS} descartado (NN fraca)")
                    continue

            # üö® Overfitting
            if detectar_overfitting(metricas, dezenas):
                ciclos_descartados += 1
                print(f"  üö® Ciclo {ciclo}/{CICLOS} descartado (overfitting)")
                continue

            medias.append(metricas["media"])
            taxas.append(metricas["taxa_11"])
            ciclos_validos += 1

            print(
                f"  ‚úÖ Ciclo {ciclo}/{CICLOS} | "
                f"M√©dia: {metricas['media']:.2f} | "
                f"11+: {metricas['taxa_11']*100:.1f}%"
            )

        if not medias:
            print("  ‚ùå Nenhum ciclo v√°lido para esta estrat√©gia.")
            continue

        media_final = statistics.mean(medias)
        taxa_final = statistics.mean(taxas)

        ranking.append({
            "estrategia": estrategia["nome"],
            "media": round(media_final, 2),
            "taxa_11": round(taxa_final, 4)
        })

        print("\nüìä Resultado da estrat√©gia:")
        print(f"  ‚úîÔ∏è Ciclos v√°lidos   : {ciclos_validos}")
        print(f"  ‚ùå Ciclos descartados: {ciclos_descartados}")
        print(f"  ‚≠ê M√©dia final      : {media_final:.2f}")
        print(f"  üéØ Taxa 11+         : {taxa_final*100:.2f}%")

        relatorio_txt.append(
            f"Estrat√©gia: {estrategia['nome']}\n"
            f"  M√©dia de pontos : {media_final:.2f}\n"
            f"  Taxa 11+        : {taxa_final*100:.2f}%\n"
            f"  Ciclos v√°lidos  : {ciclos_validos}\n"
            f"  Descartados     : {ciclos_descartados}\n"
            + "-" * 40
        )

    salvar_relatorio_txt(relatorio_txt)
    salvar_ranking_csv(ranking)


# ===============================
# üíæ SALVAR RELAT√ìRIOS
# ===============================
def salvar_relatorio_txt(linhas):
    caminho = os.path.join(RELATORIOS_DIR, f"laboratorio_{DATA_TAG}.txt")
    with open(caminho, "w", encoding="utf-8") as f:
        f.write("\n".join(linhas))


def salvar_ranking_csv(ranking):
    ranking = sorted(ranking, key=lambda x: x["taxa_11"], reverse=True)
    caminho = os.path.join(RELATORIOS_DIR, f"ranking_estrategias_{DATA_TAG}.csv")

    with open(caminho, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=["estrategia", "media", "taxa_11"])
        writer.writeheader()
        for r in ranking:
            writer.writerow(r)


# ===============================
# üöÄ MAIN
# ===============================
if __name__ == "__main__":
    print("\nüß™ LABORAT√ìRIO INTELIGENTE INICIADO\n")
    executar_laboratorio()
    print("‚úÖ Relat√≥rios e ranking gerados com sucesso\n")


================================================================================
üìÑ ARQUIVO: .\src\generator\constraints.py
================================================================================

# src/generator/constraints.py

CONSTRAINTS = {
    "impares": (8, 9),
    "primos": (5, 6),
    "multiplos_3": (4, 6),
    "fibonacci": (3, 5),
    "moldura": (9, 10),
}


================================================================================
üìÑ ARQUIVO: .\src\generator\diversity.py
================================================================================

# src/generator/diversity.py

def diversidade(jogo, jogos_anteriores, limite=12):
    """
    Garante que um novo jogo n√£o seja muito parecido com os anteriores
    """
    for anterior in jogos_anteriores:
        intersecao = len(set(jogo) & set(anterior))
        if intersecao >= limite:
            return False
    return True


================================================================================
üìÑ ARQUIVO: .\src\generator\generator.py
================================================================================

# src/generator/generator.py

import random
from src.analysis.patterns import (
    contar_impares,
    contar_primos,
    contar_multiplos_3,
    contar_fibonacci,
    contar_moldura,
)
from src.generator.constraints import CONSTRAINTS
from src.generator.diversity import diversidade

UNIVERSO = list(range(1, 26))


def jogo_valido(jogo):
    return (
        CONSTRAINTS["impares"][0] <= contar_impares(jogo) <= CONSTRAINTS["impares"][1]
        and CONSTRAINTS["primos"][0] <= contar_primos(jogo) <= CONSTRAINTS["primos"][1]
        and CONSTRAINTS["multiplos_3"][0]
        <= contar_multiplos_3(jogo)
        <= CONSTRAINTS["multiplos_3"][1]
        and CONSTRAINTS["fibonacci"][0]
        <= contar_fibonacci(jogo)
        <= CONSTRAINTS["fibonacci"][1]
        and CONSTRAINTS["moldura"][0]
        <= contar_moldura(jogo)
        <= CONSTRAINTS["moldura"][1]
    )


def gerar_jogo_18(jogos_anteriores=None, tentativas=500):
    if jogos_anteriores is None:
        jogos_anteriores = []

    for _ in range(tentativas):
        jogo = sorted(random.sample(UNIVERSO, 18))

        if not jogo_valido(jogo):
            continue

        if not diversidade(jogo, jogos_anteriores):
            continue

        return jogo

    return None


================================================================================
üìÑ ARQUIVO: .\src\generator\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\memory\perfil_vencedor.json
================================================================================

{
    "top_dezenas": [
        25,
        20,
        24,
        13,
        14,
        10,
        1,
        5,
        11,
        17,
        12,
        23,
        6,
        21,
        9
    ],
    "frequencia_dezenas": {
        "4": 15463,
        "6": 30437,
        "7": 15354,
        "11": 30967,
        "12": 30493,
        "13": 31052,
        "14": 31041,
        "15": 15399,
        "16": 15127,
        "17": 30955,
        "19": 15405,
        "21": 30392,
        "23": 30444,
        "24": 31057,
        "25": 31211,
        "5": 30995,
        "8": 15131,
        "20": 31136,
        "2": 15254,
        "1": 31006,
        "3": 15287,
        "10": 31021,
        "18": 15280,
        "22": 15251,
        "9": 25231
    },
    "media_pares": 7.85,
    "media_soma": 232.85,
    "total_jogos": 35245
}

================================================================================
üìÑ ARQUIVO: .\src\reports\export_csv.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\reports\graficos.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\reports\relatorio_txt.py
================================================================================

import os
from datetime import datetime


def salvar_relatorio(jogos_15, jogos_18, estatisticas, relatorio_avaliador):
    # üìÅ Diret√≥rio base do projeto
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))

    # üìÅ src/reports/relatorios
    DIR_RELATORIOS = os.path.join(BASE_DIR, "relatorios")
    os.makedirs(DIR_RELATORIOS, exist_ok=True)

    # üóìÔ∏è Nome do arquivo
    data = datetime.now().strftime("%Y-%m-%d_%H-%M")
    caminho = os.path.join(
        DIR_RELATORIOS,
        f"relatorio_{data}.txt"
    )


    with open(caminho, "w", encoding="utf-8") as f:
        f.write(relatorio_avaliador)
        f.write("=" * 50 + "\n\n")
        
        f.write("üìä RELAT√ìRIO FINAL ‚Äî IA LOTOF√ÅCIL\n")
        f.write("=" * 50 + "\n\n")

        f.write("üîπ ESTAT√çSTICAS DO TREINAMENTO\n")
        for k, v in estatisticas.items():
            f.write(f"{k}: {v}\n")

        # ==========================================
        # üî¢ NOVO BLOCO ‚Äî DISTRIBUI√á√ÉO DE DEZENAS
        # ==========================================
        if "dezenas_treinamento" in estatisticas:
            f.write("\n" + "-" * 50 + "\n")
            f.write("üî¢ DISTRIBUI√á√ÉO DE DEZENAS NO TREINAMENTO\n\n")

            for dezenas, total in sorted(estatisticas["dezenas_treinamento"].items()):
                f.write(f"{dezenas} dezenas ‚Üí {total} ciclos\n")

        f.write("\n" + "=" * 50 + "\n")
        f.write("üéØ 10 JOGOS ‚Äî 15 DEZENAS\n\n")

        for i, jogo in enumerate(jogos_15, 1):
            f.write(f"Jogo {i:02d}: {jogo}\n")

        f.write("\n" + "=" * 50 + "\n")
        f.write("üéØ 7 JOGOS ‚Äî 18 DEZENAS\n\n")

        for i, jogo in enumerate(jogos_18, 1):
            f.write(f"Jogo {i:02d}: {jogo}\n")

    print(f"\nüìÑ Relat√≥rio salvo em: {caminho}")

================================================================================
üìÑ ARQUIVO: .\src\reports\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\scripts\gerar_jogos_proximo_concurso.py
================================================================================

"""
üîÆ GERADOR DE JOGOS ‚Äî PR√ìXIMO CONCURSO (COM C√âREBRO SELETOR)
Gera muitos jogos, aplica vi√©s estat√≠stico, score 14/15
e elimina agressivamente os jogos fracos.
"""

from src.engine.gerador_final import gerar_jogos_finais
from src.engine.aprendiz import obter_perfil_vencedor
from src.engine.motor_multicerebro import obter_total_dezenas_atual
from src.engine.estatisticas import calcular_dezenas_quentes_frias
from src.utils.dados import carregar_resultados


# ===============================
# ‚öôÔ∏è CONFIGURA√á√ïES AVAN√áADAS
# ===============================

MODO_EXTREMO = True
SUPER_GERACAO = 1000     # Quantos jogos gerar
TOP_FINAL = 10          # Quantos sobreviver√£o

PESO_QUENTES = 3
PESO_REPETIDAS = 2
PESO_PARES = 1.5


# ===============================
# üß† FUN√á√ïES DO C√âREBRO SELETOR
# ===============================

def score_proximidade_1415(jogo, dezenas_quentes, ultimo_resultado):
    """
    Calcula qu√£o pr√≥ximo este jogo est√°
    do padr√£o hist√≥rico de 14/15 pontos.
    """
    score = 0

    # üî• Dezenas quentes
    score += len(set(jogo) & set(dezenas_quentes)) * PESO_QUENTES

    # üîÅ Repetidas do √∫ltimo concurso
    score += len(set(jogo) & set(ultimo_resultado)) * PESO_REPETIDAS

    # ‚öñÔ∏è Pares / √çmpares
    pares = sum(1 for d in jogo if d % 2 == 0)
    if 7 <= pares <= 9:
        score += PESO_PARES

    return score


def filtrar_e_selecionar(jogos, dezenas_quentes, ultimo_resultado, top_n):
    """
    Aplica score, ordena e elimina jogos fracos.
    """
    jogos_com_score = []

    for jogo in jogos:
        score = score_proximidade_1415(
            jogo,
            dezenas_quentes,
            ultimo_resultado
        )
        jogos_com_score.append((score, jogo))

    # üî• Ordena√ß√£o brutal (melhores primeiro)
    jogos_com_score.sort(reverse=True, key=lambda x: x[0])

    # ‚úÇÔ∏è Elimina√ß√£o agressiva
    selecionados = [jogo for _, jogo in jogos_com_score[:top_n]]

    return selecionados


# ===============================
# üéØ GERADOR PRINCIPAL
# ===============================

def gerar_jogos_proximo_concurso():
    print("\nüîÆ GERANDO JOGOS PARA O PR√ìXIMO CONCURSO (MODO INTELIGENTE)\n")

    # ===============================
    # üîé VERIFICA APRENDIZADO
    # ===============================
    perfil = obter_perfil_vencedor()
    if not perfil:
        print("‚ùå Nenhum perfil vencedor encontrado.")
        print("‚û°Ô∏è Execute o treinamento pelo menos uma vez.")
        return

    # ===============================
    # üî• ESTAT√çSTICAS
    # ===============================
    dezenas_quentes, dezenas_frias = calcular_dezenas_quentes_frias()

    # ===============================
    # üìä √öLTIMO RESULTADO
    # ===============================
    resultados = carregar_resultados()
    resultados = sorted(resultados, key=lambda x: x["concurso"])
    ultimo_resultado = resultados[-1]["dezenas"]

    # ===============================
    # üß† SUPER GERA√á√ÉO
    # ===============================
    jogos_brutos_15 = []
    jogos_brutos_18 = []

    for _ in range(SUPER_GERACAO):
        jogos_15, jogos_18 = gerar_jogos_finais(
            dezenas_quentes,
            dezenas_frias,
            ultimo_resultado
        )
        jogos_brutos_15.extend(jogos_15)
        jogos_brutos_18.extend(jogos_18)

    # ===============================
    # üß† C√âREBRO SELETOR
    # ===============================
    jogos_15_finais = filtrar_e_selecionar(
        jogos_brutos_15,
        dezenas_quentes,
        ultimo_resultado,
        TOP_FINAL
    )

    jogos_18_finais = filtrar_e_selecionar(
        jogos_brutos_18,
        dezenas_quentes,
        ultimo_resultado,
        TOP_FINAL
    )

    # ===============================
    # üß† INFO DO MOTOR
    # ===============================
    dezenas_motor = obter_total_dezenas_atual()
    print(f"üß† Motor ativo com {dezenas_motor} dezenas\n")

    print("=" * 60)
    print("üéØ TOP JOGOS ‚Äî 15 DEZENAS (SELECIONADOS)\n")

    for i, jogo in enumerate(jogos_15_finais, 1):
        print(f"Jogo {i:02d}: {jogo}")

    print("\n" + "=" * 60)
    print("üéØ TOP JOGOS ‚Äî 18 DEZENAS (SELECIONADOS)\n")

    for i, jogo in enumerate(jogos_18_finais, 1):
        print(f"Jogo {i:02d}: {jogo}")

    print("\n‚úÖ Jogos finais escolhidos por IA seletiva (anti-caos)\n")


if __name__ == "__main__":
    gerar_jogos_proximo_concurso()


================================================================================
üìÑ ARQUIVO: .\src\utils\comparador.py
================================================================================

def contar_acertos(jogo, resultado_real):
    return len(set(jogo) & set(resultado_real))


================================================================================
üìÑ ARQUIVO: .\src\utils\dados.py
================================================================================

import sqlite3
import os

DB_PATH = "data/lotofacil.db"


def carregar_resultados():
    """
    Carrega concursos do banco SQLite de forma inteligente.
    Detecta automaticamente como as dezenas est√£o armazenadas.
    Retorna:
    [
        {
            "concurso": int,
            "dezenas": [int, int, ..., int]
        }
    ]
    """

    if not os.path.exists(DB_PATH):
        raise FileNotFoundError(f"Banco n√£o encontrado: {DB_PATH}")

    con = sqlite3.connect(DB_PATH)
    cur = con.cursor()

    # 1Ô∏è‚É£ Descobrir estrutura da tabela concursos
    cur.execute("PRAGMA table_info(concursos)")
    colunas = [c[1] for c in cur.fetchall()]

    if "concurso" not in colunas:
        raise RuntimeError("Tabela concursos n√£o possui coluna 'concurso'")

    # 2Ô∏è‚É£ Caso 1: dezenas em colunas separadas (n1, n2, ...)
    colunas_numericas = [
        c for c in colunas
        if c.lower().startswith(("n", "d", "bola"))
    ]

    resultados = []

    if len(colunas_numericas) >= 15:
        colunas_numericas = sorted(colunas_numericas)

        query = f"""
            SELECT concurso, {",".join(colunas_numericas)}
            FROM concursos
            ORDER BY concurso DESC
        """
        cur.execute(query)

        for row in cur.fetchall():
            concurso = row[0]
            dezenas = list(map(int, row[1:]))

            resultados.append({
                "concurso": concurso,
                "dezenas": dezenas
            })

    # 3Ô∏è‚É£ Caso 2: dezenas em uma √∫nica coluna texto
    else:
        coluna_texto = None
        for c in colunas:
            if c.lower() in ("dezenas", "numeros", "resultado"):
                coluna_texto = c
                break

        if not coluna_texto:
            raise RuntimeError(
                "N√£o foi poss√≠vel identificar colunas de dezenas na tabela concursos"
            )

        cur.execute(f"""
            SELECT concurso, {coluna_texto}
            FROM concursos
            ORDER BY concurso DESC
        """)

        for concurso, texto in cur.fetchall():
            dezenas = list(map(int, texto.replace(";", ",").split(",")))

            resultados.append({
                "concurso": concurso,
                "dezenas": dezenas
            })

    con.close()

    if not resultados:
        raise RuntimeError("Nenhum concurso carregado do banco")

    return resultados


================================================================================
üìÑ ARQUIVO: .\src\utils\extrator_features.py
================================================================================

# src/utils/extrator_features.py

import numpy as np
from src.engine.aprendiz import obter_perfil_vencedor

def extrair_features(jogo, jogo_anterior=None):
    perfil = set(obter_perfil_vencedor())

    soma = sum(jogo)
    pares = sum(1 for d in jogo if d % 2 == 0)
    impares = 15 - pares

    repeticao = len(set(jogo) & set(jogo_anterior)) if jogo_anterior else 0
    perc_perfil = len(set(jogo) & perfil) / len(jogo) if perfil else 0

    dispersao = float(np.std(jogo))
    entropia = len(set(jogo)) / 25

    return {
        "soma": soma,
        "pares": pares,
        "impares": impares,
        "repeticao_anterior": repeticao,
        "perc_perfil": round(perc_perfil, 3),
        "freq_media": 0.0,   # pode evoluir depois
        "dispersao": round(dispersao, 3),
        "entropia": round(entropia, 3)
    }


================================================================================
üìÑ ARQUIVO: .\src\utils\logger.py
================================================================================

"""
üßæ LOGGER CENTRAL DO SISTEMA
Respons√°vel por logs padronizados em todo o projeto.
"""

import logging
import sys

# ==================================================
# ‚öôÔ∏è CONFIGURA√á√ÉO BASE
# ==================================================
LOGGER_NAME = "IA_Lotofacil"
LOG_LEVEL = logging.INFO  # mude para DEBUG se quiser mais detalhes

# ==================================================
# üß† CRIA LOGGER
# ==================================================
logger = logging.getLogger(LOGGER_NAME)
logger.setLevel(LOG_LEVEL)

# Evita duplicar handlers (erro comum)
if not logger.handlers:
    handler = logging.StreamHandler(sys.stdout)

    formatter = logging.Formatter(
        fmt="%(asctime)s | %(levelname)-7s | %(message)s",
        datefmt="%H:%M:%S"
    )

    handler.setFormatter(formatter)
    logger.addHandler(handler)

# ==================================================
# üö´ N√ÉO PROPAGA PARA ROOT LOGGER
# ==================================================
logger.propagate = False


================================================================================
üìÑ ARQUIVO: .\src\utils\tempo.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\src\utils\__init__.py
================================================================================



================================================================================
üìÑ ARQUIVO: .\web\app_web.py
================================================================================



